●  Apropos:
- Visit next Web site for a great experience:
  https://earizon.github.io/txt_world_domination/viewer.html?payload=../GOLang/notes.txt

- If you want to contribute to great gistory of this
  document you can take the next flight to:
@[https://www.github.com/earizon/GOLang]
  Your commits and pull-request will be immortalized
  in the Pantheon of the Unicode Gods.
────────────────────────────────────────────────────────────────────────────────
● GOLang Summary [[{101]]
  • See also: @[https://www.youtube.com/watch?v=PAAkCSZUG1c&ab_channel=TheGoProgrammingLanguage]
     GLOBAL     1<···> N git repo 1 <····> 1+ package/s
     WORKSPACE
     ===========
     ${GOPATH}/ <···················• "GLOBAL WORKSPACE for GO PROJECTS" (defaults to ${HOME}/go )
     └ bin/                           $ go env GOPATH   ← print effective/current value
     · └ hello                        Recommended to fix random problems. Add next lines to .bashrc/...:
     · └ ...                          + export GOPATH=$(go env GOPATH)
     ·                                + export PATH=$PATH:${GOPATH}/bin #
     ·
     └ src/                        ← All Source project (Git repositories) are placed in this folder
       └ github.com/user/prj01/ <··· GIT REPO 1
       · └.git/                      $ go install \          ← Install all compiled go repo's packages
       · ·                            github.com/user/prj01/   to $GOPATH/pkg, $GOPATH/bin
       · ·                           $ $GOPATH/bin/hello     ← Exec. installed package.
       · ·
       · └ hello/hello.go            <· PACKAGE 1. Import in other projects like:
       ·   hello/hello_test.go          import github.com/user/proj01/hello/...
       ·                                       └·· path from $GOPATH/src ··┘
       · └ outyet/main.go            <· PACKAGE 2
       ·   ...
       └ golang.org/x/image/    <··· GIT REPO 2, external project imported like:
       · .git/                       $ go get golang.org/x/image # <-
       · bye/bye.go                       └┬┘
       ·                                  download sources to correct path,
       ·                                  then install libs(?) to $GOPATH/pkg,
       ·                                  binaries to $GOPATH/bin
       └ ···                    <··· GIT REPO 3, (local or external "$go get ")

       WARN : DO NOT SYMLINK SRC/... TO DIRECTORIES

  • Hello World run&build                                COMPILE → EXECUTE
  ┌ ${GOPATH}/src/github.com/"myUser"/hello/hello.go - { $ go run  hello.go      ← alt 1. Quick version
  │                                                      $ go build  && ./hello  ← alt 2.
  │
  │                                           'package' must be first statement in file
  │ package main        <···················· pkg names are short,clear,lowercase, (without "_", ... chars)
  │                                           CONVENTION: function called 'New' returns type *pkg.Pkg. e.g:
  │                                           list.New()@list/list.go returns *list.List
  │                                           Use NewOtherType for OtherType != pkg.Pkg
  │
  │ import (            <··················· importing several types and functions
  │   "fmt"                               <- [[{strings.101}]]
  │    m "golang-book/chapter11/math"     <- match ./golang-book/chapert11/math/math.go
  │                                          m: alias avoid conflicts when using 2 'math' pkgs.
  │   "time"                                 [[{101.date_time}]]
  │   "flag"                                 [[{qa.UX}]]
  │   ... )
  │
  │   if m , _ == functionN() ; m == n  { <· declare/assign  m "inside" i , then pass m == n to if
  │      return 0, errors.New("n == 0")   <· return N values. Normally (result, errors)
  │   }                                      errors package is standard (no need to import) [[{qa.error_control}]]
  │                                          NOTE: return values can be named.
  │
  │   for i := 0; i < 10; i++ {            ← NO PARENTHESIS USED in 'for' or 'if'
  │     fmt.Println(n, ":", i)               break'|'continue' statements work as in C/Java/...
  │     amt := time.Duration(rand.Intn(250)) [[{101.date_time]]
  │     time.Sleep(time.Millisecond * amt)   [[}]]
  │   }
  │   ... m.Average(...)
  │   rawString01 := `lorem ipsum...       ← Multiline string definition. See also:[[{strings.101]]
  │ ... lorem ipsum ...                    @[#text_templates_summary]
  │ ....`                                    [[}]]
  │  x := 42.0
  │  //
  │  sumToX := func(b float) bool {        <- Declare+Define clouse, funct. within current exec. ctx
  │   return b == x                          x point to x defined above (WARN: x value can be changed
  │  }                                       by some other code)
  │  switch x {
  │    case x>10:                          <- code will be executed fallthrough keyword makes next
  │      ... ; fallthrough                    case be evaluated.(by default, end after 1st match)
  │                                           WARN: This behaviour differs from buggy default in C/JAVA/...
  │    case x>20:                          <- code will be executed (thanks to previous fallthrough)
  │      ...
  │    case x>30:                          <- code will NOT be executed. (Not previous fallthrough )
  │      ...
  │    default:                            <- exec. when no other case matach condition.
  │       ... default is optional ...
  │  }
  │  res, err := http.Get("...")           <- open I/O HTTP Resource [[{io.101.http]]
  │  defer res.Body.Close()                <- defer will close resources at function exit [[{qa.101}]]
  │  body, err := ioutil.ReadAll(resp.Body)  [[}]]
  │
  │  switch c := instance.(type) {         ← switch-case based on instance type
  │    case string:
  │        ...
  │  }
  │
  │ func main() {                         <- Entry point to App
  │   const (                             <- DEFINE CONSTANT VALUES [[{qa.101.inmu_code]]
  │      HELLO = "Hello"                     (The more constants, the best)
  │      WORLD = "World"
  │   )                                      [[}]]
  │ type IPv4    [4]byte                 <- Easy way to assign a type to a "bunch-of-bytes"
  │ type IPv6   [10]byte                    To convert back to []byte array: return myIPv4[:]
  │
  │                                         PARSING COMMAND LINE ARGUMENTS (@package main only) [[{qa.UX]]
  │   maxp := flag.int(
  │      "max", 6 /*def.value*/,            <- define CLI flag 'max'.
  │      "the max value")
  │   flag.parse()                          // parse
  │   fmt.println(...*maxp)                 // Referencing parsed value. [[}]]
  │
  │   var x string = HELLO+" "+WORLD       ← alt 1.  [[{strings.101}]]
  │   //  x       := HELLO+" "+WORLD       ← alt 2. (Type inference)
  │
  │
  │   var input01 float64                           [[{IO.101,strings.101]]
  │   fmt .Scanf ("%f", &input01)          ← formated input from STDIN to 'input01' var.
  │   fmt .Printf("%f", input01 )          ← formated output to STDOUT
  │   fmt .Printf(x)                       ← Printf. alt 1
  │   fmt .Println("1 + 1 = ", 1.0 + 1.0)  ← Printf. alt 2  [[}]]
  │ }
  └───────────────────────────────────────── }

• DATA STRUCTURES: [[{101.data_structure]]
                                          ########################
  type Circle struct {              <- ● # STRUCTS defininition #
    x, y, r float64                       ########################
    color   string
  }
  circle1 := Circle{0,0,4,"blue"}

  func (c Circle) area() float64 {      <- friend-function for struct
    return math.Pi * c * c * r             See also related @[#golang_interfaces]
  }
  circle1.area()                        <- Invoking friend function

  type Wheel struct {
     Circle                             <- embedded (composed) type
     material string
  }
  wheel1 := Wheel1{circle1, "iron"}
  wheel1.area                           <- calls wheel1.circle1.area


                                           ################################
  var x [5]int        ← 0-initialized   <- # ARRAY DEFINITION.            #  [[{qa.inmu_code}]]
      x[4] = 100      ← [ 0 0 0 0 100]     # FIXED LENGTH AT COMPILE TIME.#
      len(x)                               ################################
  var y := [3]float64 { 1.0, 2.0, 3.0}  <- value-initialized

  y_copy := y                           <- VALUE SEMANTIC, y_copy is a COPY-OF-ARRAY
  y_cpy[0] = 25                            <- y[0] not modified.
  byteArrayFromStr := []byte("a slice")

  array01 := []struct {                 <- array of anonymous struct type
    field1 string,                         used just in scope 'array01'
    field2 string
  } {
    {"value_1_1", "value_1_2"},
    {"value_2_1", "value_2_2"},
    ...
  }
  cases_l[0].field1
  cases_l[0].field2

  for idx, element :=  range array1 {  <- WALKING OVER ARRAYS
    // do something                       ===================
  }

  slice1 :=  make ( // zero-initialized   # slices (arrays segments, DYNAMIC SIZE) #
               []float64,                 # (Internally they look to be a link of  #
                 5 /*len*/,               #  arrays ) ##############################
                10 /*capacity*/)          - MORE WIDELY USED IN CODE THAN ARRAYS.

  array1 := []int{1,2,3,4,5}
  slice2 := array1[0:5]                <- Create slice from array
  slice2 :=append(slice2,4,5,[]int{6}) <- Slice grows on-demand.
  s3_copy := slice3                    <- reference semantics (both slices modify same values)
  s3_copy[0] = 1                       <- slice3[0] will change too.
  copy(slice3,slice2)                  <- copy of slice2 up to len [[{01_PM.TODO}]]

                                          #####################
  https://golang.org/ref/spec#Map_types]  # MAPS(DYNAMIC SIZE)#
  (Dictiona./Associat.arrays/hashtables)  #####################
  map1 :=  make (  map [string]int)       ← Declare map
  map2 := map[string]int{"three": 3, ...} ← Declare with initial values
  map1["key"] = 10
  delete(map1, "key")
  map1["no_key"]                          ← WARN: "ZERO TYPE VALUE" (no throw, no nil)
  if value1, ok := map1["key1"]; ok {     ← one line key-exists check
     ...
  } else { ... }
  map2 := map[string]map[string]string{
    "H": map[string]string{
      "name":"Hydrogen",
      "state":"gas",
    },
    ...
  }
                                            ##################
  for key, value :=   range  map1 {      ←  # WALK OVER MAPS #
    fmt.Println(                            ##################
      "Key:", key, "Value:", value)         Use for _, value if key is not needed.
  }

  import ("container/list")               #########
  var x list.List                         # Lists #
  x.PushBack(1)                           #########
  x.PushBack(2)
  ...

  import ("sort")                         ###########
  type ByOrder1 []MyType                  # Sorting #
  func (this ByOrder1) Len() int {        ###########
    return   len (this)
  }
  func (this ByOrder1)
    Less(i, j int) bool {
    return this[i].Name < this[j].Name
  }
  func (this ByOrder1) Swap(i, j int) {
    this[i], this[j] = this[j], this[i]
  }
  ...
  sort .Sort (ByOrder1(kids))      ←

  for e := l.Front();          ← l == *List   ###################
       e != nil; e = e.Next() {               # walk over Lists #
      // do something with e.Value            ###################
  }
[[}]]

• Interfaces [[{101.interfaces]] #[golang_interfaces]
  ==========
  ▸ Go proverb: "The smaller the interface the best"
  ▸ io.reader, io.writer are the most important interfaces [[{io.101]]
    in Go with just 1 method each.
    io.writer represents the ability to write a byte slice into a stream of data.
    io.reader represents the "read-end" of a stream of data.
    [[}]]

  ┌ ../devices/IDevice.go ──────
  │ type Device interface {     <- INTERFACE DECLARATION
  │   Open(string) int, error      ( type ... interface vs type ... struct )
  │   Read()       int, error
  │   Close()      error
  │ }
  └─────────────────────────────

  ▸ THERE ARE NO CLASSES IMPLEMENTING INTERFACES
   The combination of structs + struct-friends-funct play the role of classes.

  ┌ ../devices/harddisk.go ─────
  │ type HardDisk struct { ... }  <- standard type ... struct (vs type ... interface)
  │ func (d HardDisk) Open(string) ...  <- Mark Open(string) as "friend" of HardDisk
  │ func (d HardDisk) Read() ...        <- Mark Read()       as "friend" of HardDisk
  │ func (d HardDisk) Close()...        <- Mark Close()      as "friend" of HardDisk
  └─────────────────────────────                ^^^^^^^^^^^^
                                           struct friend-functions must implement all
                                           functions defined in interface.
  ┌ ../devices/tty.go ──────────                vvvvvvvvvvvv
  │ type sTTY     struct { ... }
  │ func (d HardDisk) Open(string) ...  <- Mark Open(string) as "friend" of sTTY
  │ func (d sTTY    ) Read() ...        <- Mark Read()       as "friend" of sTTY
  │ func (d sTTY    ) Close()...        <- Mark Close()      as "friend" of sTTY
  └─────────────────────────────
[[}]]

  • BUILT-IN numeric types: [[{]]
  @[https://go.dev/ref/spec#Types]
    - (u)int8/16/32/64      - rune: alias for int32
      var u uint = 7        - byte: alias for uint8
      n := byte('\n')
    - float32/64
      f1 := float64(len(int01)) ← type conversion
      var pi float32 = 22. / 7
    - complex64/128
      c := 3 + 4i   ← complex128
    - NaN, positive/negative inifinity  [[}]]

  • Built-in Strings: [[{strings.101]]
    - "asdf" + `asdf`  newlines allowed
    - len("asdf")      4
    - "asdf"[0]        ← returns a
    - String package:
      strings.Contains("test", "es")  // true
      strings.Count("test", "t")      // 2
      strings.HasPrefix("test", "te") // true
      strings.HasSuffix("test", "st") // true
      strings.Index("test", "e")      // 1
      strings.Join([]string{"a","b"}, // "a-b"
                   "-")
      strings.Repeat("a", 3)          // == "aaa"
      strings.Replace("aa","a","b",1) // "ba"
      strings.Split("a-b-c", "-")     // []string {"a","b","c"}
      strings.ToLower("TEST")         // "test"
      strings.ToUpper("test")         // "TEST"

      arr := []byte("test")           // string to byte-array
      str := string(                  // byte-array to string
              []byte{'t','e','s','t'})
    - See also: @[text_templates_summary]

    - Check if string is empty:
          strings.TrimSpace(" ")  != ""  <- Alt 1: Prefered in later versions of Go
      len(strings.TrimSpace(" ")) != 0   <- Alt 2: micro-optimization. Harder to read, but
                                                   still used.
    [[}]]

● GO Pointers: [[{101.pointers]]
  - GOLANG IS GARBAGE COLLECTED. This implies that returning pointers to function
    local variables are "OK". Local variable will stay in memory while some external
    reference is in place:
    val1 := 1
    xPtr *int = &val1 ← new pointer to val1.
    ptr1 := new(int)  ← new Pointer unnasigned
  - NO POINTER ARITHMETIC EXISTS.
  - nil pointer and nil pointer errors can arise :(

    func learnMemory() (p1, p2 *int) {
        s := make([]int, 20) // Allocate 20 ints as a single block of memory.
        s[3] = 7             // Assign one of them.
        return &s[3], &s;    // & fetch address of object.
    }
[[}]]

● Channels + GoRutines: [[{101.channels,101.goroutines]]
  • channel: CONCURRENCY-SAFE COMMUNICATION OBJECT used for:
    • Concurrent internal go routines running in parallel using
      the channel to synchronize work.
    • Async/reactive implementation (Concurrent code sending / receiving
      data in another machine outside our control).

  • Channel / Go-routines interaction:
                                             Standard function to be run as go-routine
    func goRoutine1(i int, c chan int) {   ← (vs called as part of a thread). Syntax is
        ...                                  similar to standard functions but we must
        c <- i + 1 //  <- write to channel   pass 1+ channel/s object/s to allow the
    }                                        go routine to communicate with other threads

    NOTE: We can restrict whether function/go-routine will be able to read/write
          from channel like:

    func func1(c chan   string) ... ← func1 can read/write to/from channel
    func func2(c chan<- string) ... ← func2 can write      to      channel
    func func3(c <-chan string) ... ← func3 can read          from channel

    func funcXXX (...) {
      c   := make(chan int)         // ← create new unbuffered    int channel
      cs  := make(chan string)      // ← create new unbuffered string channel
      ccs := make(chan chan string) // ← create new unbuffered string-channel channel
                                                    └────┬───┘
         ┌───────────────────────────────────────────────┘
      // • goroutines writting (trying to write) to Unbuffered channel will block
      //   when no 'peer' thread is waiting to read from such channel.
      // • Use make( chan T, N /*buffer capacity*/ ) for buffered channels.
      //   Writting goroutines will continue to writing until buffer is full.

      go goRoutine1(  0,  c) // ← start go rutine 1 ┐ Any go routine can be first
      go goRoutine1( 10,  c) // ← start go rutine 2 ├ writing to unique channel c
      go goRoutine1(─805, c) // ← start go rutine 3 ┘ and so output will be random
      fmt.Println(<-c, <-c, <-c) //                 ← in this line

      go func()   { c <- 84  }()  // inline go-routine writing value to c  channel.
      go func()   { cs<- "." }()  // inline go-routine writing value to cs channel.
      select {           ← select will wait until something is received from channel
        case i := <-c:     ←┐ // varX := <- c translates to "wait trying to read from c"
            ...             ├ One go-routine will win. All other "competing" goroutines
        case s <-cs:       ←┘ will block. (No one will be reading what they write)
            ...
        case sc <-ccs:     ←  Empty channel, NOT ready for communication.
            ...
      }
    }
[[}]]

● GOlang Testing: [[{qa.testing,qa.101]]
· @[https://golang.org/cmd/go/#hdr-Test_packages]

· $GOPATH/src/github.com/user/stringutil/reverse.go       <- File to test
  $GOPATH/src/github.com/user/stringutil/reverse_test.go  <- Sibling of reverse.go
                                                             excluded in package builds
  package stringutil
  import "testing"                      <-  @[https://golang.org/pkg/testing/]

  func TestReverse( t  *testing.T) {    <- TestXxx marks funct. as test routine
                                            var  t  injected by testing framework?

    cases_l := []struct {               <- Define struct, init array of struct inline
      input          string,
      expectedOutput string
    }{
      {"Hello, world", "dlrow ,olleH"}, ← Single array element of type struct
      ...
    }
    for _, c := range cases_l {
      output := Reverse(c.input)        <- function being tested
      if output != c.expectedOutput {
      t .Errorf(                        <- alternatively t.Fail, t.Fatal or "panic"
        "Reverse(%q) == %q, Expected %q",
         c.input, output, c.expectedOutput)

      }
    }
  }

  $ go test github.com/user/stringutil                   ← Running tests:
  → ok github.com/user/stringutil 0.165s

  func BenchmarkXxx(b *testing.B) {   <- Mark funct as Benchmarks
                                         run sequentially ($ go test -bench)
                                         (See official doc for running in parallel)
      ... some "slow" presetup ...
      b.ResetTimer()                  <- Reset benchmark after "slow" presetup.
      for i := 0; i < b.N; i++ {      <- @benchmark execution b.N b.N is adjusted
          rand.Int()                     until the benchmark function lasts long
      }                                  enough to be timed reliably.
  }                                      ( Maybe tens of millions for short codes)


                                         FUZZ TESTING (https://go.dev/doc/fuzz)
  func FuzzHex(f *testing.F) {        <- FuzzXxx marks func. as fuzz-test
                                         It will be called with random inputs in
                                         go test --fuzz

    for _, seed := range [][]byte{    <- optional. seed corpus (inputs run by default)
       {}, {0}, {0x232}, {1, 2} }
    { f.Add(seed) }                   <- register seed input.
                                       alternative, use testdata/fuzz/"Name_of_fuzz_test"

    f.Fuzz(
      func(t *testing.T               <- Fuzz test target function to be tested.
           in []byte ) {                 'in' random input, must match type of seed.
      enc := hex.EncodeToString(in)
      out, err := hex.DecodeString(enc)
      if err != nil {
        t.Fatalf("%v: decode: %v", in, err)
      }
      if !bytes.Equal(in, out) {
        t.Fatalf("%v: not equal after round trip: %v", in, out)
      }
    })
  }

Use t.Skip("...") to skip a test or a non-valid input in Fuzz tests.

  func TestFoo(t *testing.T) {                    SUBTESTS AND SUB-BENCHMARKS
      // <setup code>                             ===========================
      t.Run("A=1", func(t *testing.T) { ... }) <- Run allow to define subtest/sub-benchmarks
      t.Run("A=2", func(t *testing.T) { ... })    allowing to share common setup/tear-down
      t.Run("B=1", func(t *testing.T) { ... })
      // <tear-down code>
  }
  $ go test -run ''                   <- Run all tests.
  $ go test -run Foo                  <- Run test  matching top-level "TestFoo*".
  $ go test -run Foo/A=               <- Run tests matching top-level "TestFoo*" && subtests matching "A="
  $ go test -run /A=1                 <- Run tests matching top-level "Test*"    && subtests matching "A=1"
  $ go test -run=FuzzFoo/9ddb952d9814 <- run Fuzz test matching top-level "FuzzFoo" with given input.


func TestMain(m *testing.M) {    <- Optional, low-level primitive, only necessary for casual testing
                                    Control code run on main-thread, pre-setup, teardown
                                    - call flag.Parse() here if TestMain uses flags
  os.Exit(m.Run())                  If present it will be run (instead of Test*, Benchmarks*, Fuzz*)
}
[[}]]

● File I/O [[{io.101.files]]
• Simple 'String' ←(read-from/write-to)→ 'File'


• ·········································· write 'String' to 'File'
  import ( "os" )                            ========================
  func WriteFile() {                         in-memory String → file
      F_NAME := "test.txt"                 (no buffer, no looping, no async,...)
      const data []byte := []("lorem...")
      if err := os.WriteFile(F_NAME,
         err != nil {
          panic(err)
      }
      defer file.Close()                   ← Don't forget!!!

      if writtenLen, err := file.WriteString("...") ;
      /* └────┬───┘*/err != nil {
      // effectively written string len.
          panic(err)
      }
  }

 • ········································· Read 'File' to 'String'
  import ( "os" )                           =======================
  func ReadFile() {
      F_NAME := "test.txt"                   file → in-memory String
      if data, err := os.ReadFile(F_NAME);   ← go 1.16+
               err != nil {                    go 1.15-: ioutils.ReadFile
         panic(err)
      }
  }

• ·········································· Read "pieces" of files
                                             ========================
  import (
      "io"
      "os"
  )

  func ReadPieceOfFile() {              ←   WARN:  error control removed
      f, err := os.Open("/tmp/dat")
      ... error control ...
      defer  f.Close()                  ← "defer": Don't forget to close

      b1 := make([]byte, 5)
      n1, err := f.Read(b1)             ← read 5 bytes (@ start-of-file)
      ... error control ...               n1: effective bytes read

      o2, err := f.Seek(6, 0)           ← Move in file for next read/write
      ^                 ^  ^              Move relative to:
      ·                 ·  └─············ 0: file-origin
      ·                 ·                 1: current offset
      ·                 ·                 2: file-end
      ·                 └················ offset "jump" in bytes
      └·································· new file offset
                                          For write-append behavior is undefined
      b2 := make([]byte, 2)
      n2, err := io.ReadAtLeast(f, b2, 2) ← TODO: Wait otherwise?

      _, err = f.Seek(0, 0)

      r4 := bufio.NewReader(f)
      b4, err := r4.Peek(5 /* bytes */)

  }

• ·········································· Read "pieces" of files  [[{io.101.buffers]]
                                             using buffers:
                                             ========================
  import (
      "bufio"             ← bufio implements a buffered reader
      "io"                  efficiency with many small reads
      "os"
  )

  func ReadPieceOfFile() {              ←   WARN:  error control removed
      f, err := os.Open("/tmp/dat")
      ... error control ...
      defer  f.Close()                  ← "defer": Don't forget to close

      r4 := bufio.NewReader(f)          ← "wrap" File into buiffer
      b4, err := r4.Peek(5 /* bytes */) ← Operate on buffer
  }                                          // [[}]]

[[}]]

● buffers: [[{io.101.buffers,01_PM.TODO]]
@[https://pkg.go.dev/bytes]
  type Buffer        <··· Manage byte[] arrays with File-like interface: Read (with drain) & Write
  -----------
  func NewBuffer      (buf []byte) *Buffer
  func NewBufferString(s string  ) *Buffer
  func (b *Buffer) Bytes() []byte
  func (b *Buffer) Cap()   int
  func (b *Buffer) Grow(n int)
  func (b *Buffer) Len() int
  func (b *Buffer) Next(n int) []byte                    <··· returns slice containing next-n-bytes from buffer,
                                                              advancing the buffer as if bytes had been returned by Read
  func (b *Buffer) Read(p []byte) (n int, err error)     <··· reads next-len(p) bytes from buffer (or until buffer is drained).
                                                              return effective 'n' bytes read. err == io.EOF if there are no
                                                              more bytes to read, (unless len(p) is zero); otherwise it is nil.
  func (b *Buffer) ReadByte() (byte, error)
  func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
  func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
  func (b *Buffer) ReadRune() (r rune, size int, err error)
  func (b *Buffer) ReadString(delim byte) (line string, err error)
  func (b *Buffer) Reset()
  func (b *Buffer) String() string
  func (b *Buffer) Truncate(n int)
  func (b *Buffer) UnreadByte() error
  func (b *Buffer) UnreadRune() error
  func (b *Buffer) Write(p []byte) (n int, err error)
  func (b *Buffer) WriteByte(c byte) error
  func (b *Buffer) WriteRune(r rune) (n int, err error)
  func (b *Buffer) WriteString(s string) (n int, err error)
  func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)


  var buf bytes.buffer // no need to init (make)
  buf.write([]byte("test"))

[[io.101.buffers}]]


● built-in JSON support: data structure <- en|de-coding -> JSON string [[{io.serialization.JSON]]
  package main

  import (
      "encoding/json"                   <- Builtin library!!!
      "fmt"
      "os"
  )

  type customStruct01 struct {
      Page   int
      Fruits []string
  }

  type customStruct02 struct {
      Page   int      `json:"page_i"`   <- Only Fields starting with capital
      Fruits []string `json:"fruit_l"`     letters will be en|de-coded to/from
  }                                        JSON
                       └···········┴─   <- tags allow to customized output
                                           JSON key names (otherwise same name
                                           is used).

  func main() {                            OBJECT to JSON string
                                           =====================
    bolB, _ := json.Marshal(true)       <- encoding basic data types to JSON
    fmt.Println(string(bolB))              (boolean, int, float, strings,..,
                                           as well as slices and maps.

    res1D := &customStruct01{           <- No problem to encode custom structs.
        Page:   1,
        Fruits: []string{"...", ...}
    }
    res1B, _ := json.Marshal(res1D)

                                           JSON string to OBJECT  (example 1)
                                           =====================
    byt := []byte(                      <- INPUT JSON
           `{"num":6.1,"strs":["a","b"]}`)

    var dat map[string]interface{}      <- STEP 1) Variable to store decoded JSON
                                           map of strings to arbitrary data types.

    if err := json.Unmarshal(byt, &dat);<- STEP 2) Unmarshal
       err != nil { panic(err) }        <- error control
    fmt.Println(dat)

    num := dat["num"].(float64)         <- STEP 3) convert map values to suitable type.

                                           nested data requires a series of conversions.
    strs := dat["strs"].([]interface{}) <- 1) Convert "strs" values to array of any-type
    str1 := strs[0].(string)            <- 2) Convert element to string
    fmt.Println(str1)
                                           JSON string to OBJECT  (example 2)
                                           =====================
    str :=                              <- INPUT JSON (to be decoded to custom data type)
        `{                                 - Adds additional type-safety
           "page": 1,                      - eliminates manual type assertions.
         "fruits": ["apple", "peach"]
        }`

    res := customStruct02{}
    json.Unmarshal([]byte(str), &res)
    fmt.Println(res.Fruits[0])

                                           USING STREAMS (os.Writers children)
                                           =============

    enc := json.NewEncoder(os.Stdout)    <- Create JSON stream encoder (os.Stdout, HTTP response bodie,...)
    d := map[string]int{"...": 5, ...}
    enc.Encode(d)
  }

  https://go.dev/blog/json

  • JSON API Summary  (https://pkg.go.dev/encoding/json)
    func Compact                type UnsupportedTypeError
    func HTMLEscape             type UnsupportedValueError
    func Indent                 type SyntaxError
    func Marshal                type MarshalerError
    func MarshalIndent          type InvalidUnmarshalError
    func Unmarshal              type UnmarshalTypeError
    func Valid /*isValid?*/


    type Decoder             type Encoder     type   MarshalJSON
    - NewDecoder             - NewEncoder     type UnmarshalJSON
    - Buffered               - Encode         type Unmarshaler
    - Decode v any           - SetEscapeHTML  type Marshaler
    - DisallowUnknownFields  - SetIndent      - Error
    - InputOffset                             - Unwrap
    - More                                    - Error
    - Token                                   - Unwrap
    - UseNumber

    type Number   type Delim  type RawMessage
    - Float64     - String()  type Token
    - Int64
    - String
[[io.serialization.JSON}]]

● Builtin functions (@[https://golang.org/ref/spec#Built-in_functions]) [[{101.builtin]]

  @[https://golang.org/pkg/builtin/]

  • append(slice []Type, elems ...Type) []Type :
    - append elements to the end-of-slice. Returns new updated slice.
      that must be stored, often in existing var. holding the original slice.

     sliceRefInFunc  = append( sliceRefInFunc , elem1, elem2)
     sliceRefInFunc  = append( sliceRefInFunc , anotherSlice...)

     slice           = append([]byte("hello "), "world"...)  ← appending string to
                                                               byte slice is legal

  • cap(v Type) int : ← return capacity of v, according to its type

  • close(c chan<- Type) :  closes channel.
    · channel must be either bidirectional or send-only.
      WARN: It should be executed only by the sender, never the receiver,
            effect: shuts down channel after last-sent-value is received.
    · WARN: After last-value has been received from a closed channel c,
           any receive from c will succeed without blocking, returning the
           zero value for the channel element.
    · WARN: "x, ok := <-c" will also set ok to false for a closed channel.

  • copy(dst, src []Type) int :                                               [slice]
    · copy elements from source-slice into destination-slice.
    · return number-of-elements copied, (it will be the minimum of len(src)|len(dst).
    · WARN: source and destination may overlap.

  • delete(m map[Type]Type1, key Type) :                                      [map]
    · delete element with specified key from map.
    · If m == nil or key not in map, it results in a no-op.
      WARN: This could mean a programming error. Check first that key
            exists and throw like .
            if !val, ok := map01["key"]; ok {
              // raise error
            }

  • len(v Type) int : returns length-of-v, according to its type              [data_structure]

  • make(t Type, size ...IntegerType) Type :
    · allocate+initialize object of type slice|map|chan
        Like "new", 1st argument is a type, not a value.
      Unlike "new", return type is same as argument-type (vs pointer )

  • new(Type) *Type : allocates memory and return pointer to newly
                      allocated type's "zero-value"

  • panic(v interface{}) :
    · stop normal execution of current-goroutine
    · termination sequence can be controlled by the built-in func. recover() .

  • recover() interface{} :
    · allows program to manage behavior for panicking goroutine.
      Executing a call to recover inside a deferred function                    [TODO]
      (but not any function called by it) stops the panic sequence
      by restoring normal execution and retrieves the error
      value passed to the call of panic.
    · If recover called outside deferred-function it will not stop panic sequence.

   ...
[[}]]

● Building a reusable library: [[{]]
  ┌─ $GOPATH/src/.../strutil/reverse.go ─┐ build:
  │  package stringutil                  │ $ go build github.com/user01/strutil
  │                                      │ install:
  │  func Reverse(s string) string {     │ $ go install github.com/user01/strutil
  │      r := []rune(s)                  │
  │      for i, j := 0, len (r)-1;       │ Ussage:
  │          i <   len (r)/2;            │   package main
  │          i, j = i+1, j-1 {           │   import  "github.com/user01/strutil"
  │          r[i], r[j] = r[j], r[i]     │   ...
  │      }                               │   s := strutil.Reverse("!oG, olleH"))
  │      return string(r)                │
  │  }                                   │
  └──────────────────────────────────────┘
[[}]]

● Error Management: [[{qa.101.error_control]]

• CONTEMPLATED (RECOVERABLE) ERRORS:
@[https://golang.org/ref/spec#Errors]
  predeclared error is defined as:

  type error interface {  ← interface adopted by convention to
      Error() string        represent contemplated error condition
  }                         (nil value representing no error).

  n, err := os.Read(f,...)
  if err != nil {             ← Check for errors.
     // Fix contemplated error
     // (otherwise panic...)
  }

     THE CONVENTION IN THE GO LIBRARIES IS THAT EVEN WHEN A PACKAGE
     USES PANIC INTERNALLY, ITS EXTERNAL API STILL PRESENTS EXPLICIT ERROR
     RETURN VALUES.

• NON CONTEMPLATED (UN-RECOVERABLE) ERRORS:
@[https://blog.golang.org/defer-panic-and-recover]
  · panic  : (java throw  )
  · defer  : (java finally) cleanup after function exit.
  · recover: (java catch  ) (only useful inside deferred functions)

  ┌─ errorhandling.go ─────────────────────────────┐
  │  package main                                  │
  │                                                │
  │  import (                                      │
  │    "fmt"                                       │
  │  )                                             │
  │                                                │
  │  type MyCustomError struct {                   │
  │       data1, data2 string                      │
  │       data3        int                         │
  │  }                                             │
  │                                                │
  │  func (e MyCustomError) Error() string {       │
  │       return fmt.Sprintf("%s %s %d:" ,         │
  │               e.data1, e.data2, e.data3)       │
  │  }                                             │
  │                                                │
  │  func returnMyCustomError() (int, error) {     │
  │     return -1, MyCustomError{ "data1", "data2", 3 }
  │  }                                             │
  │                                                │
  │  func throwPanic() {                           │
  │     panic ("Let's panic now");                 │
  │  }                                             │
  │                                                │
  │  func main() {                                 │
  │     defer func() /* catch( */ {                │
  │        if r := recover(); r!=nil {             │   ← recover: Capture panics
  │           fmt.Printf("recovered\n")            │
  │        }                                       │
  │     }()                                        │
  │                                                │
  │     defer func()/* finally */ {                │
  │       fmt.Printf("cleaning all resources\n")   │
  │     }()                                        │
  │                                                │
  │     _, err := returnMyCustomError()            │
  │     if  err != nil {                           │
  │        fmt.Printf("%s\n",err.Error())          │
  │     }                                          │
  │     throwPanic()                               │
  │  }                                             │
  └────────────────────────────────────────────────┘
[[}]]

● Context (Core lib 1.7+) [[{101,arch.distributed,async/reactive.101,qa.error_control]]
@[https://pkg.go.dev/context]
@[https://blog.golang.org/context]
- Moved to Core lib in 1.7 (from golang.org/x/net/context).
- It allows the use of contexts for cancelation, timeouts, and passing request-scoped
  data (AAA/JWT Tokens, ...) in other standard library packages, including net,
  net/http, and os/exec and across API boundaries.
- safe to use by simultaneous concurrent goroutines. [[{concurrency.101}]]

  type Context interface {
      Done() <-chan struct{}  // returns channel that is closed when this Context is canceled/times out.

      Err() error             // indicates why context was canceled, after Done channel is closed.

      Deadline() (deadline time.Time, ok bool) //

      Value(key interface{}) interface{} // returns value or nil
  }

- Example ussage: https://github.com/go-chi/chi                 [[{IO.http]]
  lightweight, composable router for building Go HTTP services.
  built on the new context package introduced in Go 1.7 to handle signaling,
  cancelation and request-scoped values across a handler chain. [[}]]
[[}]]

● Viper App Config:("12 factor") [[{devops.configuration.viper,01_PM.low_code]]
• Low code application configuration library.
• Features support:
  · Find/load/unmarshal JSON/TOML/YAML/HCL/INI/envfile/Java-properties
  · default values.
  · override through command line flags.
  · alias system (rename parameters without breaking code).
  · Make it easy to tell the difference between when a user has provided
    a command line or config file which is the same as the default.

• PRECEDENCE ORDER:
  1) explicit call to Set  4) config
  2) command line flag     5) key/value store
  3) env                   6) default

• Working with "injected" OS ENViroment VARiables:
  · Viper treats ENV VARs variables as case sensitive.
  · Ex.1:
    SetEnvPrefix("SPF") ←  use "SPF_..."  prefix for ENV.VARs.
    AutomaticEnv()      ←  Alt 1: any viper.Get("SPF_...") will
                                  automatically query ENV.VARs
    BindEnv("id")       ←  Alt 2: viper.Get("SPF_ID") will query ENV.VARs
    BindEnv("id",       ←  Alt 3: Alias/Backward compatibility
       "deprecated",...)          It will query also for SPF_DEPRECATED,...

   NOTE: ENV.VAR value will be read each time it is accessed
         (vs constant value after first query)

  · SetEnvKeyReplacer(string...) *strings.Replacer :
    allows to use strings.Replacer object to rewrite Env keys (to an extent).
    Use-case: Replace conflictive characters  in Get() with "_" delimiters
              in (OS) ENV.VARs.
    ( replacers can also be established in NewWithOptions function
      using EnvKeyReplacer that also accepts a StringReplacer interface
      for custom replace-logic ).

  - By default empty ENV.VARs are considered unset, falling back to
    next conf source). AllowEmptyEnv() will consider them set as "".
[[}]]

[[101}]]

● DevOps 101 [[{devops.101]]
@[https://github.com/tldr-pages/tldr/blob/master/pages/common/go*.md]
@[https://github.com/tldr-pages/tldr/blob/master/pages/common/gox.md]

  $ go get github.com/user/uuid← Download+install package, specified by its import path
  $ go run file.go             ← Compile and run source file containing 'main' pkg+,unc main()
  $ go install                 ← Compile+install current package

  $ go bug                     ← Open web page to start bug-report           [QA]
                                 https://golang.org/cmd/go/#hdr-Start_a_bug_report.
 · Compiling:
   https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies.

   $ go build path_to_main.go  ← Compile file
      -o path/bin_exec           ← Optional
   $ go build                \ ← Compile full package
        -race flag               ← (optional) Add data race detection [qa]
        path_to_package

   $ go clean -n               ← Remove object files and cached files.
                               @[https://golang.org/cmd/go/#hdr-Remove_object_files_and_cached_files]
                                 -n : Print remove commands, do NOT remove anything.
   $ go clean -cache           ← Delete build cache
   $ go clean -testcache       ← Delete all cached test results
   $ go clean -modcache        ← Delete the module cache:
                                 WARN!!!: This deletes everything inside ${GOPATH}/go/pkg/mod/cache
                                 shared by any module (not just the cache for modules realted to the
                                 one we are working on, requiring potentially expensive downloads )

   $ go doc ...                ← Show documentation for a package | symbol.
                                @[https://golang.org/cmd/go/#hdr-Show_documentation_for_package_or_symbol]

   $ go doc                    ← Show documentation for current package
   $ go doc {{encoding/json}}  ← Show package doc. and exported symbols
                                 -all flag: Show also doc. for symbols
                                 -src flag: Show also sources
   $ go doc -all -src \        ← Show a specific symbol.
            {{encoding/json.Number}}

   $ godoc -http=:6060         ← Serv. doc for go packages on port 6060.
   $ godoc fmt                 ← Display help for package "fmt"
   $ godoc fmt Printf          ← Display help for the func. "Printf" of "fmt" package
   $ godoc -write_index \      ← Create index file
       -index_files=.../file
   $  godoc -http=:6060 \      ← Use the given index file to search the docs
       -index \
       -index_files=.../file

   $ go env ...                ← Manage env.vars used by the Go toolchain.
                               @[https://golang.org/cmd/go/#hdr-Print_Go_environment_information]

   $ go env                    ← Show all environment variables
   $ go env {{GOPATH}}         ← Show a specific environment variable
   $ go env -w{{GOBIN}}=dir    ← Set an environment variable
   $ go env -u{{GOBIN}}        ← Reset an environment variable's value


   $ go fix {{packages}}       ← Update packages to use new APIs.          [qa]
                               @[https://golang.org/cmd/go/#hdr-Update_packages_to_use_new_APIs]


   $ go generate               ← Generate Go files by running commands     [low_code]
                                 within source files.
                               @[https://golang.org/cmd/go/#hdr-Generate_Go_files_by_processing_source]

   $ go list  ....             ← List packages or modules.
                               @[https://golang.org/cmd/go/#hdr-List_packages_or_modules]
   $ go list  ./...            ← List packages
                                 -json: render output in json format
   $ go list std               ← List standard packages
   $ go list -m -u all         ← List module dependencies and available    [qa][troubleshooting]
                                 updates (for deprecated modules)
                                 'go get' checks for deprecated modules needed to
                                 build packages named on the command line

   $ go mod ...                ← Module maintenance
                               @[https://golang.org/cmd/go/#hdr-Module_maintenance]
   $ go mod init $modName      ← Initialize new module in current directory
   $ go mod download           ← Download modules to local cache
   $ go mod tidy               ← Add missing and remove unused modules     [qa]
   $ go mod verify             ← Verify dependencies have expected content
   $ go mod vendor             ← Copy sources of all dependencies into the
                                 vendor directory
                               @[https://blog.gopheracademy.com/advent-2015/vendor-folder/]

   $ go test ...               ← Tests Go packages ending with _test.go.
                               @[https://golang.org/cmd/go/#hdr-Testing_flags]
   $ go test -v -bench         ← Test package found in current directory
                                 - v     flag (Optional): Verbosely
                                 - bench flag (Optional): Run all benchmarks
                                   Use flag similar to -benchtime 50s to restrict
                                   benchmark run to 50 secs.
   $ go test -v ./...          ← Test packages in current dir +  all subdirs ("...")


   $ gofmt                     ← Tool for formatting Go source code.
                               @[https://golang.org/cmd/gofmt/]
   $ gofmt source.go           ← Format file to STDOUT (-w to overwrite)
   $ gofmt -s source.go        ← Format file, then simplify the code, write result to
                                 STDOU (-w to overwrite)
   $ gofmt -e source.go        ← Print all (including spurious) errors


   $ goimports ...             Updates Go import lines, add missing, removing unreferenced
                             @[https://godoc.org/golang.org/x/tools/cmd/goimports]
   $ goimports file.go         ← Display results to STDOUT (-w to overwrite)
   $ goimports --d file.go     ← Display diffs to STDOUT (-w to overwrite input)
   $ goimports -local \        ← Set the import prefix string after 3rd-party packages
     package_path file.go        (comma-separated list)

   $ gops ...                  CLI tool which lists and diagnoses Go processes currently
                               running on your system.
                             @[https://github.com/google/gops]
   $ gops                      ← Print all go processes running locally
   $ gops $PID                 ← Print more information about a process
   $ gops tree                 ← Display process tree
   $ gops stack $pid|$addr     ← Print current stack trace from a target program
   $ gops memstats $pid|addr   ← Print current runtime memory statistics

   $ goreload                  Live reload utility
                             @[https://github.com/acoshift/goreload]
   $ goreload -b bin_path \    ← Set the name of binary file to watch (defaults to .goreload)
     file.go
   $ goreload --logPrefix \    ← Set custom log prefix (defaults to goreload)
     $prefix file.go
   $ goreload --all            ← Reload whenever any file changes
[[}]]

● modules (v1.13+) [[{devops.101.modules]]
  @[https://golangbyexample.com/package-vs-module-golang/]
  • module: directory containing a collection of nested and related go packages
  • ${MODULE_ROOT}/go.mod defines:
    - module import path.
    - Dependency requirements for successful build.
      (It also locks them to their correct version)
    NOTE: It allows to remove dependency on $GOPATH/src folder.
  • ${MODULE_ROOT}/go.sum:
    - cryptographic hash of all project's dependent modules.

  • A collection of packages can now be called as module when
    there is a requirement to version them separately or
    a common piece of code to be shred across multiple projects.

    ##################                      │ │      #################
    # BEFORE MODULES #                      │ │      # AFTER MODULES #
    # (package only) #                      │ │      #################
    ##################                      │ │
    · packages only                         │ │
                                            │ │
      $GOPATH/bin/  ←······························→ $GOPATH/bin/
                                            │ │
      $GOPATH/src/  ←······························→ Not required anymore
             └─┬─┘                          │ │
       All source code must be              │ │
       placed here                          │ │
      $GOPATH/pkg/  ←······························→ $GOPATH/pkg/mod/ (with versioning)
             └─┬─┘                          │ │      $GOPATH/pkg/mod/cache
               │                            │ │                      └─┬─┘
      Download route:                       │ │                     download-cache
      -    No versioning!!! :               │ │                   + zipped-code
      $ go get github.com/pborman/uuid      │ │
      will download package to              │ │
      $GOPATH/src/github.com/pborman/uuid   │ │
         latest version always used!!!      │ │
       - No version in downloaded path !!!  │ │
       - Updates overwrite current ver!!!   │ │
                                            │ │
      - No native dependency management ←········→ go.mod, go.sum
        or method to specify project        │ │    (precise dependencies version
        dependencies                        │ │     Updates without breaking anythin  ).
        "Patchy"(non-native) solution used  │ │
        ("dep","glide")                     │ │

    $ export GOPATH=$(go env GOPATH)
    $ export DIR="$GOPATH/github.com/user/project
    $ mkdir $DIR ; cd $DIR          ← Make sure project is inside $GOPATH

    $ go mod init                   ← Initialize go modules in project dir.
                                      (go.mod will be created)
    $ cat ./go.mod
      ┌────────────────────────────────┐
      │ module github.com/user/project ← Import path
      │                                │
      │ go 1.14                        ← go version used to create the module
      └────────────────────────────────┘

    $ edit ./uuid.go
      ┌──────────────────
      │ package main
      │
      │     import (
      │     "fmt"
      │     ...
      │     "github.com/pborman/uuid"  ←··· transitive external dependency
      │ )
      │
      │ func main() { ...  }
      │ ...

    $ go mod tidy   ← Download all required dependencies (indicated in *.go)
                      Update ./go.mod
    $ cat ./go.mod
      ┌──────────────────────────────────────────┐
      │ module github.com/user/project           │
      │                                          │
      │ go 1.14                                  │
      │ require github.com/pborman/uuid v1.2.1   ← version added
      │ ....                                     │


    $ cat ./go.sum
      github.com/google/uuid  v1.0.0        h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=
      github.com/google/uuid  v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
      github.com/pborman/uuid v1.2.1        h1:+ZZIw58t/ozdjRaXh/3awHfmWRbzYxJoAdNJxe/3pvw=
      github.com/pborman/uuid v1.2.1/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=

● GOPROXY (go 1.13+ modules)
@[https://jfrog.com/blog/why-goproxy-matters-and-which-to-pick/]

• Before GOPROXY module dependencies were downloaded directly from
  their source repositories, triggering build mutability and
  availability (modules deleted or versions edited remotely).

• GOPROXY (go 1.13+) controls the source of Go module downloads.    [[{qa]]
  helping to assure deterministic and secure builds by redirecting
  Go module download requests to a GOPROXY cache repository .       [[}]]

• "GOPROXies" can be:
  • Public GOPROXY : (free ones like proxy.golang.org , ...)
    hosting OOSS modules "published" by third parties in public VCS repos.
    $ export GOPROXY=https://proxy.golang.org   ← redirect downloads to this repo

    In addition, public "GOPROXies" can also provide detailed module info. e.g:
    http://pkg.go.dev   ← It UI allow to search for modules, show stats, ..

                GitHub    ··┐
                            ·
    PUBLIC      BitBucket ··┤                     ┌·· Developer
  SRC.CODE                  ├··→  GOPROXY ·······─┤
                SVN       ··┤                     └·· CI System
                            ·
                Mercurial ··┘                        ·         ·
               ·         ·                           ·         ·
               ·         ·                           ·         ·
               └────┬────┘                           └────┬────┘
   ────────── SOURCE PRODUCERS ──────────────────── SOURCE CONSUMERS
               ┌────┴────┐                           ┌────┴────┐
               ·         ·                           ·         ·
               ·         ·                           ·         ·
                GitHub    ··┐                        ·         ·
                            ·
    PUBLIC      BitBucket ··┤    ┌───────┐        ┌·· Developer
  +PRIVATE                  ├··→ │GOPROXY│←····┬·─┤
  SRC.CODE      SVN       ··┤    └───────┘     ·  └·· CI System
                            ·                  ·
                Mercurial ··┘              $GOPRIVATE
                                           $GONOSUMDB
                                               ·
                ┌───────────┐                  ·
                │Private VCS│ ←················┘
                │  repos    │
                └───────────┘

  • PUBLIC + PRIVATE GO MODULES : (GOPROXY + GOPRIVOTE env.var)

    · Alternative 1, GOPRIVOTE: is used to bypass GOPROXY and GOSUMDB. (preferred)
      $ export GOPROXY=https://proxy.golang.org,direct    ← for public  repos
      $ export GOPRIVATE=*.internal.mycompany.com         ← for private repos
                                                            bypass GOPROXY and GOSUMDB
        WARN : It also ensures that private module repositories are not "leaked"   [security][101]
      through requests to a public GOPROXY server.

    · Alternative 2, GONOSUMDB var:  including refs to private modules.
      It allows Go client to resolve both public and private mod. dependencies,
      it doesn’t enforce immutability or availability requirements for
      private modules.

    · Alternative 3, private GOPROXY: Used to store both public and private modules
      in on your own infrastructure:
      · Public  modules cached by proxying a public GOPROXY.
      · Private modules cached by proxying from their VCS repos.
      e.g. using Artifactory (Enterprise Universal -go modules, npm packages,
           helm charts,...- Repository Manager)
      $ export GOPROXY="https://:@my.artifactory.server/artifactory/api/go/go
      $ export GONOSUMDB="github.com/mycompany/*,github.com/mypersonal/*"
[[}]]

● Simple HTTP client / server [[{io.http]]
  • HTTP Simple client @[https://gobyexample.com/http-clients]

    package main                              ← Exec like   $ go run http-clients.go

    import ( "bufio" "fmt" "net/http" )

    func main() {
      resp, err :=
         http.Get("http://....")              ←  convenient shortcut around
      if err != nil {                            creating http.Client instance
          panic(err)                             , then calling its Get method
      }                                           using http.DefaultClient with
                                                  sensible default settings

      defer resp.Body.Close()                 ←  Close I/O resource on defer.

      fmt.Println("Res.Status:", resp.Status)

      scanner := bufio.NewScanner(resp.Body)
      for i:= 0; scanner.Scan() && i<5; i++ { ← Print first 5-lines of the
        fmt.Println(scanner.Text())             res.body.
      }

      if err := scanner.Err(); err != nil {
          panic(err)
      }
    }

  • HTTP Simple server @[https://gobyexample.com/http-servers]
    import ( "fmt" "net/http" )

    func hello( w    http.ResponseWriter,    ← handler 1
          req *http.Request) {
      fmt.Fprintf( w , "hello\n")
    }

    func headers(                             ← handler 2. echo Req.headers
        w    http.ResponseWriter,                          to Res.body
        req *http.Request) {
      for key, value_l
          := range req.Header {      ←  key: Header name, value: 1+ values
        for _, h := range value_l {
          fmt.Fprintf( w ,
            "%v: %v\n", key, h)
        }
      }
    }

    func main() {
        http.HandleFunc("/hello"  , hello  )
        http.HandleFunc("/headers", headers)
        http.ListenAndServe(":8090", nil) // nil: use def.router just defined
    }

  • See also: https://github.com/valyala/fasthttp
    - HTTP tuned for high performance.
    - Zero memory allocations in hot paths.
    - Up to 10x faster than net/http .

• Simple HTTP server using gin-gonic:
  https://github.com/gin-gonic/

  PRE-SETUP:
  go 1.16+
  $ go get -u github.com/gin-gonic/gin

  import "github.com/gin-gonic/gin"
  import "net/http" // Optional, needed if reusing constants like http.StatusOK

  func main() {
    router := gin.Default()
    router.Static("/assets", "./assets")
    router.StaticFS("/more_static", http.Dir("my_file_system"))
    router.StaticFile("/favicon.ico", "./resources/favicon.ico")
    router.StaticFileFS("/more_favicon.ico", "more_favicon.ico", http.Dir("my_file_system"))

    // Listen and serve on 0.0.0.0:8080
    router.Run(":8080")
  }


● See also https://github.com/gravityblast/fresh:   [[{qa.UX.flesh]]
  Fresh is a command line tool that builds and (re)starts your web
  application everytime you save a Go or template file.
   If the web framework you are using supports the Fresh runner,
  it will show build errors on your browser.
   It currently works with Traffic, Martini and gocraft/web.
  $ go get github.com/pilu/fresh # Installation
  $ cd /path/to/myapp            # Ussage
  $ Start fresh

     It will watch for file events, and every time you
  create/modify/delete a file it will build and restart the
  application. If go build returns an error, it will log it in the tmp
  folder.                                         [[01_PM.UX.flesh}]]
[[io.http}]]

● TIME MANAGEMENT: @[https://golang.org/pkg/time/] [[{101.date_time]]
  start   := time.Now()
  elapsed := time.Now().Sub (start) // time diff

  func After(d Duration) <-chan Time
  func Sleep(d Duration)
  func Tick (d Duration)  <-chan Time

  • type Duration:
    func ParseDuration(s string) (Duration, error)
    func Since(t Time) Duration
    func Until(t Time) Duration
    func (d Duration) Hours      () float64
    func (d Duration) Minutes    () float64
    func (d Duration) Nanoseconds() int64
    func (d Duration) Round(m Duration) Duration
    func (d Duration) Seconds() float64
    func (d Duration) String() string
    func (d Duration) Truncate(m Duration) Duration

  • type Location:
    func FixedZone(name string, offset int) *Location
    func LoadLocation(name string) (*Location, error)
    func LoadLocationFromTZData(name string, data []byte) (*Location, error)
    func (l *Location) String() string
  • type Month
    func (m Month) String() string
  • type ParseError
    func (e *ParseError) Error() string
  • type Ticker
    func NewTicker(d Duration) *Ticker
    func (t *Ticker) Stop()
  • type type Time
    func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
    func Now() Time
    func Parse(layout, value string) (Time, error)
    func ParseInLocation(layout, value string, loc *Location) (Time, error)
    func Unix(sec int64, nsec int64) Time
    func (t Time) Add(d Duration) Time
    func (t Time) AddDate(years int, months int, days int) Time
    func (t Time) After(u Time) bool
    func (t Time) AppendFormat(b []byte, layout string) []byte
    func (t Time) Before(u Time) bool
    func (t Time) Clock() (hour, min, sec int)
    func (t Time) Date() (year int, month Month, day int)
    func (t Time) Day() int
    func (t Time) Equal(u Time) bool
    func (t Time) Format(layout string) string
    func (t *Time) GobDecode(data []byte) error
    func (t Time) GobEncode() ([]byte, error)
    func (t Time) Hour() int
    func (t Time) ISOWeek() (year, week int)
    func (t Time) In(loc *Location) Time
    func (t Time) IsZero() bool
    func (t Time) Local() Time
    func (t Time) Location() *Location
    func (t Time) MarshalBinary() ([]byte, error)
    func (t Time) MarshalJSON() ([]byte, error)
    func (t Time) MarshalText() ([]byte, error)
    func (t Time) Minute() int
    func (t Time) Month() Month
    func (t Time) Nanosecond() int
    func (t Time) Round(d Duration) Time
    func (t Time) Second() int
    func (t Time) String() string
    func (t Time) Sub(u Time) Duration
    func (t Time) Truncate(d Duration) Time
    func (t Time) UTC() Time
    func (t Time) Unix() int64
    func (t Time) UnixNano() int64
    func (t *Time) UnmarshalBinary(data []byte) error
    func (t *Time) UnmarshalJSON(data []byte) error
    func (t *Time) UnmarshalText(data []byte) error
    func (t Time) Weekday() Weekday
    func (t Time) Year() int
    func (t Time) YearDay() int
    func (t Time) Zone() (name string, offset int)
    type Timer
    func AfterFunc(d Duration, f func()) *Timer
    func NewTimer(d Duration) *Timer
    func (t *Timer) Reset(d Duration) bool
    func (t *Timer) Stop() bool
    type Weekday
    func (d Weekday) String() string
[[}]]

● Go Text Templates [[{strings.templates,devops,]]
@[https://pkg.go.dev/text/template?utm_source=oficina24x7.com]
  - Used, among others, by helm charts.
  - Example:

    type Inventory struct {
        Material string
        Count    uint
    }

    tmpl, err := template.New("test")                   // ← Each template must be named
          .Parse(                                       // ← parse("compile") template
          "{{.Count}} items are made of {{.Material}}"  // ← UTF-8 Template
    )
    // A tpl s associated with 0+ tpls by using a tpl invocation to instantiate them
    if err != nil { panic(err) }
    err = tmpl.Execute(                                 // ← Execute template
           os.Stdout,
           Inventory{"wool", 17}                        // ←
    )
    if err != nil { panic(err) }

  - TIPs:
    {{- ...  : ← trim trailing white spaces.
    ... -}}  : ← trim leading white-spaced.

    Note: "{{- 3 }}"             → trim white spaces
          "{{-3  }}"             → -3 number
          "{{23 -}} < {{- 45}}"  → "23<45"
    {{`"output"`}} ← raw string constant


    Actions :
    {{/* a comment */}}
    {{- /* a comment with white space trimmed from preceding and following text */ -}}
    - Comments:
      - dropped from output.
      - May contain newlines,
      - do not nest, must start and end at the delimiters.

    {{if pipeline}} T1 {{end}}
      If pipeline value is empty, no output is generated; otherwise, T1 executed.
    {{if pipeline}} T1 {{else}} T0 {{end}}
      If pipeline value is empty, T0 executed, otherwise, T1 executed.
    {{if pipeline}} T1 {{else if pipeline}} T0 {{end}}

    {{range pipeline}} T1 {{end}}
            ^
            array/slice/map/channel.
            cursor in T1 ("." dot) set to the successive elements
    {{range pipeline}} T1 {{else}} T0 {{end}}

    {{template "name"}}  (sort of "include")
    template "name" executed with nil data.
    {{template "name" pipeline}}
    template "name" executed with dot set to the value of the pipeline.

    {{block "name" pipeline}} T1 {{end}}
    shorthand for defining and executing a template in place

    {{with pipeline}} T1 {{end}}
    If pipeline empty, no output , otherwisedot set to the value and T1 executed.
    {{with pipeline}} T1 {{else}} T0 {{end}}

    Arguments
    (See official doc for other args)
    - $piOver2 → expands to value of variable.
      $        → expands to data passed as argument to execute (start value of ".")
    - .Field   → expands to value of (struct) field.
    - $x.Field1→ expands to value of (struct) field of variable.
    - .Key     → expands to value of (map   ) field of variable.
    - $x.Field1.Key1.Field2.Key2
    - .Method  → expands to (one/two) return value/s (with cursor as receiver)
        (If optional second args is non-nil, execution terminates
         and error returned to caller as value)
    - function  → same as .Method but for functions (vs methods).
      The name of a niladic function, such as
    - parenthesized instance of one the above, for grouping.
      - result may be accessed by a field or map key. Ex:
        - print (.F1 arg1) (.F2 arg2)
        - (.StructValuedMethod "arg").Field

    Pipelines
    A pipeline may be "chained" with '|'.

    Variables
    $variable := pipeline  ← Captures pipeline output for later reuse.

    range $index, $element := pipeline  ← when pipeline output is an array/slice index
                                          or map key/value

    Variable's scope is that of frame control structure ("if"/"with"/"range")  or
    from declaration to end-of-template otherwise.

    {{printf "%q" "output"}}   ← fun call.
    {{"output" | printf "%q"}} ← fun call whose final arg comes from previous command.
    {{printf "%q" (print "out" "put")}} ← A parenthesized argument.
    {{"put" | printf "%s%s" "out" | printf "%q"}}
    {{"output" | printf "%s" | printf "%q"}}
    {{with "output"}}{{printf "%q" .}}{{end}}
    {{with $x := "output" | printf "%q"}}{{$x}}{{end}}

    {{with $x := "output"}}{{printf "%q" $x}}{{end}}    ← alt 1
    {{with $x := "output"}}{{$x | printf "%q"}}{{end}}  ← alt 2 (pipelined)


    Predefined global functions
    - and x y : Returns boolean AND of its arguments
    - call funA x y ..: return result of funA(x, y , ...)
    - html            : Returns escaped HTML
    - index x 1 2 3   : x[1][2][3], x is a map/slice/array.
    - slice x 1 2     : is, in Go syntax, x[1:2],
    - js              : Returns escaped JavaScript
    - len x           : integer length of x
    - not
    - or
    - print/f/ln      : alias for fmt.Sprint/f/ln
    - urlquery x      : Returns escaped value of x
    - comparision ops:
      - eq|ne|lt|le|gt|ge arg1 arg2

    Nested template definitions
  {{define "T1"}}ONE{{end}}   ← Template definitions must appear at the top of tpl
  {{define "T2"}}TWO{{end}}
  {{define "T3"}}
     {{template "T1"}}        ← Using template, Output: ONE
     {{template "T2"}}                                  TWO
  {{end}}
  {{template "T3"}}`

  • See also "Sprig: Useful template functions for Go templates."
  @[https://masterminds.github.io/sprig/]
    - String : trim, wrap, randAlpha, plural, etc.
    - String List : splitList, sortAlpha, etc.
    - Integer Math : add, max, mul, etc.
    - Integer Slice : until, untilStep
    - Float Math : addf, maxf, mulf, etc.
    - Date : now, date, etc.
    - Defaults : default, empty, coalesce, fromJson, toJson,
      toPrettyJson, toRawJson, ternary
    - Encoding : b64enc, b64dec, etc.
    - Lists and List : list, first, uniq, etc.
    - Dictionaries and Dict : get, set, dict, hasKey, pluck,
      dig, deepCopy, etc.
    - Type Conversion : atoi, int64, toString, etc.
    - Path and Filepath : base, dir, ext, clean, isAbs,
      osBase, osDir, osExt, osClean, osIsAbs
    - Flow Control : fail
    - Advanced
      - UUID: uuidv4
      - OS : env, expandenv
      - Version Comparison : semver, semverCompare
      - Reflection: typeOf, kindIs, typeIsLike, etc.
      - Cryptographic and Security: derivePassword, sha256sum,     [cryptography]
        genPrivateKey, etc. [security]
      - Network: getHostByName
[[}]]

● https://github.com/tal-tech/go-zero [[{01_PM.low_code,IO.http,arch.distributed,arch.mobile,01_PM.TODO]]
• web+rpc framework that integrates lots of engineering practices.
• go-zero contains simple API description syntax and code generation
 'goctl' to generate Go, iOS, Android, Kotlin, Dart, TypeScript,
  JavaScript from .api files with goctl.
[[}]]

● GraphQL Server [[{01_PM.low_code,arch.integration,IO.graphql,persistence.sql,01_PM.TODO]]
  - Related: low_code/automatic DDBB to GraphQL tools:
    - https://graphjin.com "Build APIs in 5 minutes not weeks"
    - https://www.graphile.org/postgraphile/
      Extensible high-performance automatic GraphQL API for PostgreSQL

@[https://betterprogramming.pub/implement-a-graphql-server-with-ent-and-gqlgen-in-go-8840f086b8a8]
• This post will walk you through how to implement GraphQL server
  using ent, and gqlgen.
• ...In terms of statically typed APIs, sqlboiler has similar
  functionality, but the difference is that the ent is a scheme-first
  tool that creates a database and typed API from a schema file. The
  sqlboilder is a database-first ORM that creates a typed API from a
  database
[[}]]

● External Links: [[{01_PM.EXT_RESOURCE]]
  - @[https://golang.org/doc/]
  - @[https://golang.org/ref/spec]
  - @[https://golang.org/doc/effective_go.html]
  - @[https://golang.org/pkg/]
  - @[https://golang.org/doc/cmd]
  - @[https://golang.org/doc/diagnostics.html]
[[}]]

● Goxygen ("JHipster" like in Go) [[{01_PM.low_code,io.http]]
  https://github.com/Shpota/goxygen

  Goxygen generates a Web-project-skeleton with:
  - BACKEND : Go server
  - FRONTEND: Angular|React*|Vue
  - Configuration: Dockerfile+docker-compose files (development|production environments).
  - DDBB:  MongoDB*|MySQL|PostgreSQL

  - USSAGE: # go 1.17+
    $ go run github.com/shpota/goxygen@latest \
      init \
      --frontend react \                               angular|react*|vue
      --db postgres \                                  mongo* |mysql | postgres
      my-app

    $ cd my-app
    $ docker-compose up # http://localhost:8080.


    Layout of skeleton project: (React/MongoDB example)

    my-app
    ├─ server               # Go project files
    │  ├ db                 # MongoDB communications
    │  ├ model              # domain objects
    │  ├ web                # REST APIs, web server
    │  ├ server.go          # the starting point of the server
    │  └ go.mod             # server dependencies
    ├─ webapp
    │  ├ public             # icons, static files, and index.html
    │  ├ src
    │  │ ├ App.js           # the main React component
    │  │ ├ App.css          # App component-specific styles
    │  │ ├ index.js         # the entry point of the application
    │  │ └ index.css        # global styles
    │  ├ package.json       # front end dependencies
    │  ├ .env.development   # holds API endpoint for dev environment
    │  └ .env.production    # API endpoint for prod environment
    │
    ├─ Dockerfile           # builds back end and front end together
    ├─ docker-compose.yml   # prod environment deployment descriptor
    ├─ docker-compose-dev.yml # runs local MongoDB for development needs
    ├─ init-db.js           # creates a MongoDB collection with test data
    ├─ .dockerignore        # specifies files ignored in Docker builds
    ├─ .gitignore
    └─ README.md            # guide on how to use the generated repo
  [[}]]

● https://github.com/mitchellh/mapstructure  [[{IO.serialization,persistence,qa.error_control]]
   library for decoding generic map values to structures and vice versa,
  while providing helpful error handling.

   This library is most useful when decoding values from some data
  stream (JSON, Gob, etc.) where you don't quite know the structure of
  the underlying data until you read a part of it. You can therefore
  read a map[string]interface{} and use this library to decode it into
  the proper underlying native Go structure.
[[}]]

● What's new: [[{01_PM.WHATS_NEW]]
@[https://golang.org/doc/devel/release]
  • go1.19 (released 2021-08-16) @[https://go.dev/doc/go0.19]
  • go1.18 (released 2021-08-16) @[https://go.dev/doc/go0.18]
    - Introduction of Generics.
  • go1.17 (released 2021-08-16) @[https://go.dev/doc/go1.17]
   · []T (slice) may now be converted to *[N]T (array pointer type).
     WARN: first case in which a type conversion can panic at run time.
     · unsafe.Add(ptr, len) returns updated pointer unsafe:
       Pointer(uintptr(ptr) + uintptr(len)).
     · unsafe.Slice(ptr/* type *T */, len) returns a slice of type []T
       whose underlying array starts at ptr and whose length and capacity are len.

   · go Tool:
     · removed transitive deps graphs in modules. A module specifying
       go 1.17+ will contains an explicit 'require' directive.
       $ go mod tidy -go=1.17      <- new '-go' flag to help porting to new version
       $ go mod tidy -compat=1.17  <- allows support for older (or only newer) ver.

     · // Deprecated: Module deprecation comments in go.mod.
       $ go get ← now prints a warning if a module needed to build packages
                  named on the command line is deprecated.
       $ go list -m -u prints deprecations for all dependencies
                    use -f | -json to show the full message
       NOTE: 'go' command considers different major versions to be distinct
             → This mechanism may be used, to provide users with migration
               instructions for a new major version.

   · go get
     · go get -insecure flag removed.
     · go get prints a deprecation warning when installing commands outside the
       main module (without the -d flag).
       go install cmd@version should be used instead to install a command at a
                              specific version (@latest, @v1.2.3,...)

   · vendor contents
     · go mod vendor now annotates vendor/modules.txt with the go version indicated
                     by each vendored module in its own go.mod file.
                     If main module specifies go 1.17+ it omits go.mod and go.sum
                     files for vendored dependencies, which can otherwise interfere
                     with the ability of the go command to identify the correct
                     module root when invoked within the vendor tree.

   · go mod download invoked without arguments will no longer save sums for
                     downloaded module content to go.sum.
                     use '$ go mod download all ' to save sums for all modules.

   · prefers //go:build lines over // +build

   · go run example.com/cmd@v1.0.0 // new support for version suffix

   · 'vet' tool now warns about calls to signal.Notify with incoming signals [[{qa]]
     being sent to an unbuffered channel. Using an unbuffered channel risks
     missing signals sent on them as signal.
     Notify does NOT block when sending to a channel. For example:
     c := make(chan os.Signal)
     // signals sent on c before channel is read from.
     // This signal may be dropped as c is unbuffered.
     signal.Notify(c, os.Interrupt)                                         [[}]]

   · 'vet' tool now warns about methods named As, Is or Unwrap on types
     implementing the error interface that have a different signature than
     the one expected by the errors package.
   · improved format of stack traces
   · Functions containing closures can now be inlined.

  • go1.16 (released 2021-02-16) @[https://golang.org/doc/go1.16]
    · moudles-aware mode enabled regardless of go.mod being present.
    · go command supports including static files|file trees as part
      of the final executable.
    · new runtime/metrics package introduces stable interface for        [[{SLC.profiling]]
      reading implementation-defined metrics from the Go runtime.
       It supersedes functions like runtime.ReadMemStats, debug.GCStats
      and is significantly more general and efficient.                   [[}]]
  • go1.15 (released 2020-08-11) @[https://golang.org/doc/go1.15]
    · Core lib: new  time/tzdata package allowing to embed timezone
      database into a program touse even when timezone ddbb is not
      available in local system. It increases program size by ~800KB.
  • go1.14 (released 2020-02-25) @[https://golang.org/doc/go1.14]       [[{101,qa.error_control]]
    · performance improvement of most uses of "defer" to incur
      almost zero overhead compared to calling the deferred
      function directly. As a result, "defer" can now be used in
      performance-critical code without overhead concerns.              [[}]]
    · -d=checkptr compile-time option for adding instrumentation
      to check that Go code is following unsafe.Pointer safety
      rules dynamically. This option is enabled by default
      (except on Windows) with the -race or -msan flags.  It checks:
    · crypto/x509: Certificate.CreateCRL now supports Ed25519 issuers. [cryptography]

  • go1.13 (released 2019-09-03) @[https://golang.org/doc/go1.13]
    - 1st stable version with Module support.

  • go1.12 (released 2019-02-25) @[https://golang.org/doc/go1.12]

  • go1.11 (released 2018-08-24) @[https://golang.org/doc/go1.11]

  • go1.10 (released 2018-02-16) @[https://golang.org/doc/go1.10]

  • go1.9  (released 2017-08-24) @[https://golang.org/doc/go1.9]

  • go1.8  (released 2017-02-16) @[https://golang.org/doc/go1.8]

  • go1.7  (released 2016-08-15) @[https://golang.org/doc/go1.7]

  • go1.6  (released 2016-02-17) @[https://golang.org/doc/go1.6]

  • go1.5  (released 2015-08-19) @[https://golang.org/doc/go1.5]

  • go1.4  (released 2014-12-10) @[https://golang.org/doc/go1.4]

  • go1.3  (released 2014-06-18) @[https://golang.org/doc/go1.3]

  • go1.2  (released 2013-12-01) @[https://golang.org/doc/go1.2]

  • go1.1  (released 2013-05-13) @[https://golang.org/doc/go1.1]

  • go1    (released 2012-03-28) @[https://golang.org/doc/go1]
[[}]]
