## External Links                               [[{01_PM.EXT_RESOURCE]]
* <https://golang.org/doc/>
* <https://golang.org/ref/spec>
* <https://golang.org/doc/effective_go.html>
* <https://golang.org/pkg/>
* <https://golang.org/doc/cmd>
* <https://golang.org/doc/diagnostics.html>    [[}]]

# GOLang Summary [[{101,devops.101]]

* See also: <https://www.youtube.com/watch?v=PAAkCSZUG1c&ab_channel=TheGoProgrammingLanguage>

  ```
  | GLOBAL     1<···> N git repo 1 <····> 1+ package/s
  | WORKSPACE
  | ===========
  | ${GOPATH}/ <······ "GLOBAL WORKSPACE for GO PROJECTS" (defaults to ${HOME}/go )
  | ·                   $ go env GOPATH   ← print effective/current value
  | ·                   Recommended (fix random problems). Add next lines to .bashrc/...:
  | ·                 + export GOPATH=$(go env GOPATH)
  | ·                 + export PATH=$PATH:${GOPATH}/bin #
  | └ bin/         <·· go install installs to $GOBIN (def.: $GOPATH/bin)
  | · bin/hello
  | ·
  | ·
  | ·  ┌········ Before modules (1.13+) source project (Git repositories) MUST
  | ·  ·         be placed here. After modules it's still recommended.
  | · ┌┴┐
  | └ src/github.com/user/prj01/ <· GIT REPO 1
  |   · └ .git/                  $ go install \          < Install all compiled go repo's packages
  |   · ·                         github.com/user/prj01/   to $GOPATH/pkg, $GOPATH/bin
  |   · ·                        $ $GOPATH/bin/hello     < Exec. installed package.
  |   · ·
  |   · └ hello/hello.go            <· PACKAGE 1. Import in other projects like:
  |   ·   hello/hello_test.go          import github.com/user/proj01/hello/...
  |   ·                                       └·· path from $GOPATH/src ··┘
  |   · └ outyet/main.go            <· PACKAGE 2
  |   ·   ...
  |   src/golang.org/x/image/    <··· GIT REPO 2, external project imported like:
  |   · .git/                       $ go get golang.org/x/image # <-
  |   · bye/bye.go                       └┬┘
  |   ·                                  download sources to correct path,
  |   ·                                  then install libs(?) to $GOPATH/pkg,
  |   ·                                  binaries to $GOPATH/bin
  |   └ ···                    <··· GIT REPO 3, (local or external "$go get ")
  |
  |   WARN : DO NOT SYMLINK SRC/... TO DIRECTORIES
  ```

## Hello World run&build                              
  ```
  |  COMPILE ··> EXECUTE like:
  |  $ go run  hello.go     # alt 1. Quick version
  |  $ go build  && ./hello # alt 2.
  |
  | $ cat ${GOPATH}/src/github.com/"myUser"/hello/hello.go 
  |
  |                                     // 'package' statement must be first statement in file
  | package main                        //< 'main' tells that pacakge should compile as an executable
  |                                     //  (vs shared library), having a "main" entry point.
  |                                     //  pkg.names for libraries are short,clear,lowercase (without
  |                                     //  conflictive /[_@^...]/ chars)
  |                                     //  CONVENTION: function called 'New' returns type *pkg.Pkg
  |                                     //  e.g:
  |                                     //  list.New() at ./list/list.go returns *list.List
  |                                     //  Use New'OtherType' for OtherType != pkg.Pkg
  |                                
  | import (                            //< importing several types and functions
  |   "fmt"                             //< [[{strings.101}]]
  |    pkgM "book/chapter11/math"       //< match ./golang-book/chapert11/math/math.go
  |    pkgN "book/chapter12/math"           pkgM/N: alias avoiding conflicts when using
  |                                         2 '.../math' packages.
  |   "time"                                [[{101.date_time}]]
  |   "flag"                                [[{qa.UX}]]
  |   ... )
  |
  |   if m , _ == functionN() ; m == 0  //< declare/assign  m "inside" i , then pass m == n to if
  |    { return 0, errors.New("n==0") } //< return N values. Normally (result, errors)
  |                                     //  errors package is standard (no need to import) 
  |                                     //  NOTE: return values can be named. [[{qa.error_control}]]
  |
  |   for i := 0; i < 10; i++ {         //< NO PARENTHESIS USED in 'for' or 'if'
  |     fmt.Println(n, ":", i)          //  break'|'continue' statements work as in C/Java/...
  |     amt :=                          //
  |       time.Duration(rand.Intn(250)) //  [[{101.date_time]]
  |     time.Sleep                      //  
  |       (time.Millisecond * amt)      //  [[101.date_time}]]
  |   }
  |   ... m.Average(...)
  |   rawString01 := `lorem ipsum...    //< Multiline string def. 
  | ... lorem ipsum ...                 //                       
  | ....`                               //
  |  x := 42.0
  |  //
  |  sumToX := func(b float) bool {     //< Declare+Define clouse, funct. within 
  |                                     //   current exec. ctx (sumToX will have stack
  |                                     //   == private Stack + "parent" stack at def. point
  |   return b == x                     //   x point to x defined above
  |  }                                  //   WARN: x value can be changed by some other code
  |  switch x {
  |    case x>10:                       //
  |      ...                            // 
  |      ... ; fallthrough              //< `fallthrough`: evaluate next case  (x>20)
  |                                     // WARN: This behaviour differs from (buggy)
  |                                     // C/JAVA/... (a break is needed to stop evaluating)
  |    case x>20: 
  |      ...
  |    case x>30:
  |    default:                         //< (optional) execute if no previous case matches.
  |      ... 
  |  }
  |  res, err := http.Get("...")        //< open I/O HTTP Resource [[{io.101,io.http]]
  |  defer res.Body.Close()             //< defer will close resources at fun.exit [[{qa.101}]]
  |  body, err :=                       //
  |    ioutil.ReadAll(resp.Body)        // [[}]]
  |
  |  switch c := instance.(type) {      //< switch-case based on instance type
  |    case string:
  |        ...
  |  }
  |
  | func main() {                       //< Entry point to App
  |   const (                           //< DEFINE CONSTANT VALUES [[{qa.101.inmu_code]]
  |      HELLO = "Hello"                //  (The more constants, the best)
  |      WORLD = "World"
  |   )                                 //  [[}]]
  | type IPv4    [4]byte                //< Easy way to assign a type to a "bunch-of-bytes"
  | type IPv6   [10]byte                // To convert back to []byte array: return myIPv4[:]
  |
  |                                     // PARSING COMMAND LINE ARGUMENTS (@package main only) [[{qa.UX]]
  |   maxp := flag.int(
  |      "max", 6 /*def.value*/,        //< define CLI flag 'max'.
  |      "the max value")
  |   flag.parse()                      //< parse
  |   fmt.println(...*maxp)             //< Referencing parsed value. [[}]]
  |
  |   var x string = HELLO+" "+WORLD    //< alt 1.  [[{strings.101}]]
  |   //  x       := HELLO+" "+WORLD    //< alt 2. (Type inference)
  |
  |
  |   var input01 float64               //         [[{IO.101,strings.101]]
  |   fmt .Scanf ("%f", &input01)       //< formated input from STDIN to 'input01' var.
  |   fmt .Printf("%f", input01 )       //< formated output to STDOUT
  |   fmt .Printf(x)                    //< Printf. alt 1
  |   fmt .Println("1+1=", 1.0+1.0)     //< Printf. alt 2  [[}]]
  | }
  ```

## Interfaces [[{101.interfaces]]
* Go proverb: "The smaller the interface the best"  [[{qa.best_patterns,qa.101}]]
* io.reader, io.writer are the most important interfaces [[{io.101]]
  in Go with just 1 method each.
  `io.writer` represents the ability to write a byte slice into a stream of data.
  `io.reader` represents the "read-end" of a stream of data.
[[io.101}]]

* ```
  |$ cat ../devices/IDevice.go 
  | type Device interface {    //< INTERFACE DECLARATION
  |   Open(string) int, error  //  ( type ... interface 
  |   Read()       int, error  //    vs type ... struct )
  |   Close()      error
  | }
  ```

* KEYPOINT: THERE ARE NO CLASSES IMPLEMENTING INTERFACES.<br/>
  The combination of structs + struct-friends-funct play the role of classes.

  ```
  | $ cat .../devices/harddisk.go 
  | type HardDisk struct { ... }  <- standard type ... struct (vs type ... interface)
  | func (d HardDisk) Open(string) ...  <- Mark Open(string) as "friend" of HardDisk
  | func (d HardDisk) Read() ...        <- Mark Read()       as "friend" of HardDisk
  | func (d HardDisk) Close()...        <- Mark Close()      as "friend" of HardDisk
  |                                             └────┬─────┘
  |                                        struct friend─functions must implement all
  |                                        functions defined in interface.
  |                                             ┌────┴─────┐
  | type sTTY     struct { ... }
  | func (d HardDisk) Open(string) ...  <- Mark Open(string) as "friend" of sTTY
  | func (d sTTY    ) Read() ...        <- Mark Read()       as "friend" of sTTY
  | func (d sTTY    ) Close()...        <- Mark Close()      as "friend" of sTTY
  ```
[[}]]

## BUILT-IN numeric types [[{data_structures.101]]
* <https://go.dev/ref/spec#Types>
  ```
  · (u)int8/16/32/64      - rune: alias for int32
    var u uint = 7        - byte: alias for uint8
    n := byte('\n')
  · float32/64
    f1 := float64(len(int01)) ← type conversion
    var pi float32 = 22. / 7
  · complex64/128
    c := 3 + 4i   ← complex128
  · NaN, positive/negative inifinity  [[data_structures.101}]]
  ```

## Built-in Strings [[{strings.101]]
  ```
  "asdf" + `asdf`  // newlines allowed
  len("asdf")      // 4
  "asdf"[0]        // ← returns a

  // ------ String package --------------------------------
    strings.Contains("test", "es")  // true
    strings.Count("test", "t")      // 2
    strings.HasPrefix("test", "te") // true
    strings.HasSuffix("test", "st") // true
    strings.Index("test", "e")      // 1
    strings.Join([]string{"a","b"}, // "a-b"
                 "-")
    strings.Repeat("a", 3)          // == "aaa"
    strings.Replace("aa","a","b",1) // "ba"
    strings.Split("a-b-c", "-")     // []string {"a","b","c"}
    strings.ToLower("TEST")         // "test"
    strings.ToUpper("test")         // "TEST"

    arr := []byte("test")           // string to byte-array
    str := string(                  // byte-array to string
            []byte{'t','e','s','t'})
  // See also: text_templates

  // ------ Check if string is empty ------------------------
        strings.TrimSpace(" ")  != ""  //< Alt 1: Prefered in later versions of Go
    len(strings.TrimSpace(" ")) != 0   //< Alt 2: micro-optimization. Harder to read, but
                                       //         still used.
  ```
  [[strings.101}]]

## GO Pointers [[{101.pointers]]
- GOLANG IS GARBAGE COLLECTED. This implies that returning pointers to function
  local variables are "OK". Local variable will stay in memory while some external
  reference is in place:
  ```
  | val1 := 1
  | xPtr *int = &val1 ← new pointer to val1.
  | ptr1 := new(int)  ← new Pointer unnasigned
  ```
- NO POINTER ARITHMETIC EXISTS.
- nil pointer and nil pointer errors can arise :(

  ```
  | func learnMemory() (p1, p2 *int) {
  |     s := make([]int, 20) // Allocate 20 ints as a single block of memory.
  |     s[3] = 7             // Assign one of them.
  |     return &s[3], &s;    // & fetch address of object.
  | }
  ```
[[}]]

## Channels + GoRutines [[{101.channels,101.goroutines]]

* channel: CONCURRENCY-SAFE COMMUNICATION OBJECT used for:
  * Concurrent internal go routines running in parallel using
    the channel to synchronize work.
  * Async/reactive implementation (Concurrent code sending / receiving
    data in another machine outside our control).

* Channel / Go-routines interaction:
  ```
                                           Standard function to be run as go-routine
  func goRoutine1(i int, c chan int) {   ← (vs called as part of a thread). Syntax is
      ...                                  similar to standard functions but we must
      c <- i + 1 //  <- write to channel   pass 1+ channel/s object/s to allow the
  }                                        go routine to communicate with other threads
  ```

  NOTE: We can restrict whether function/go-routine will be able to read/write
        from channel like:

  ```
  | func func1(c chan   string) ... ← func1 can read/write to/from channel
  | func func2(c chan<- string) ... ← func2 can write      to      channel
  | func func3(c <-chan string) ... ← func3 can read          from channel
  |
  | func funcXXX (...) {
  |   c   := make(chan int)         // ← create new unbuffered    int channel
  |   cs  := make(chan string)      // ← create new unbuffered string channel
  |   ccs := make(chan chan string) // ← create new unbuffered string-channel channel
  |                                                 └────┬───┘
  |      ┌───────────────────────────────────────────────┘
  |   // • goroutines writting (trying to write) to Unbuffered channel will block
  |   //   when no 'peer' thread is waiting to read from such channel.
  |   // • Use make( chan T, N /*buffer capacity*/ ) for buffered channels.
  |   //   Writting goroutines will continue to writing until buffer is full.
  |
  |   go goRoutine1(  0,  c) // ← start go rutine 1 ┐ Any go routine can be first
  |   go goRoutine1( 10,  c) // ← start go rutine 2 ├ writing to unique channel c
  |   go goRoutine1(─805, c) // ← start go rutine 3 ┘ and so output will be random
  |   fmt.Println(<-c, <-c, <-c) //                 ← in this line
  |
  |   go func()   { c <- 84  }()  // inline go-routine writing value to c  channel.
  |   go func()   { cs<- "." }()  // inline go-routine writing value to cs channel.
  |   select {           ← select will wait until something is received from channel
  |     case i := <-c:     ←┐ // varX := <- c translates to "wait trying to read from c"
  |         ...             ├ One go-routine will win. All other "competing" goroutines
  |     case s <-cs:       ←┘ will block. (No one will be reading what they write)
  |         ...
  |     case sc <-ccs:     ←  Empty channel, NOT ready for communication.
  |         ...
  |   }
  | }
  ```
[[101.channels}]]

## buffers [[{io.101.buffers,01_PM.TODO]]

* <https://pkg.go.dev/bytes>
  ```
  | type Buffer        <··· Manage byte[] arrays with File-like interface: Read (with drain) & Write
  | -----------
  | func NewBuffer      (buf []byte) *Buffer
  | func NewBufferString(s string  ) *Buffer
  | func (b *Buffer) Bytes() []byte
  | func (b *Buffer) Cap()   int
  | func (b *Buffer) Grow(n int)
  | func (b *Buffer) Len() int
  | func (b *Buffer) Next(n int) []byte                    <··· returns slice containing next-n-bytes from buffer,
  |                                                             advancing the buffer as if bytes had been returned by Read
  | func (b *Buffer) Read(p []byte) (n int, err error)     <··· reads next-len(p) bytes from buffer (or until buffer is drained).
  |                                                             return effective 'n' bytes read. err == io.EOF if there are no
  |                                                             more bytes to read, (unless len(p) is zero); otherwise it is nil.
  | func (b *Buffer) ReadByte() (byte, error)
  | func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
  | func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
  | func (b *Buffer) ReadRune() (r rune, size int, err error)
  | func (b *Buffer) ReadString(delim byte) (line string, err error)
  | func (b *Buffer) Reset()
  | func (b *Buffer) String() string
  | func (b *Buffer) Truncate(n int)
  | func (b *Buffer) UnreadByte() error
  | func (b *Buffer) UnreadRune() error
  | func (b *Buffer) Write(p []byte) (n int, err error)
  | func (b *Buffer) WriteByte(c byte) error
  | func (b *Buffer) WriteRune(r rune) (n int, err error)
  | func (b *Buffer) WriteString(s string) (n int, err error)
  | func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)
  |
  | var buf bytes.buffer // no need to init (make)
  | buf.write([]byte("test"))
  ```
[[io.101.buffers}]]

## Builtin functions [[{101.builtin]]

* (<https://golang.org/ref/spec#Built-in_functions>)

* <https://golang.org/pkg/builtin/>

* `append(slice []Type, elems ...Type) []Type` :<br/>
  append elements to the end-of-slice. Returns new updated slice.
  that must be stored, often in existing var. holding the original slice.
  ```
  |sliceRefInFunc  = append( sliceRefInFunc , elem1, elem2)
  |sliceRefInFunc  = append( sliceRefInFunc , anotherSlice...)
  |
  |slice           = append([]byte("hello "), "world"...)  ← appending string to
  |                                                          byte slice is legal
  ```

* `cap(v Type) int`: return capacity of v, according to its type

* close(c chan<- Type) :  closes channel.
  * channel must be either bidirectional or send-only.
    WARN: It should be executed only by the sender, never the receiver,
          effect: shuts down channel after last-sent-value is received.
  * WARN: After last-value has been received from a closed channel c,
         any receive from c will succeed without blocking, returning the
         zero value for the channel element.
  * WARN: "x, ok := <-c" will also set ok to false for a closed channel.

* copy(dst, src []Type) int :                                               [slice]
  * copy elements from source-slice into destination-slice.
  * return number-of-elements copied, (it will be the minimum of len(src)|len(dst).
  * WARN: source and destination may overlap.

* delete(m map[Type]Type1, key Type) :                                      [map]
  * delete element with specified key from map.
  * If m == nil or key not in map, it results in a no-op.
    WARN: This could mean a programming error. Check first that key
          exists and throw like .
    ```
    | if !val, ok := map01["key"]; ok {
    |   // raise error
    | }
    ```

* len(v Type) int : returns length-of-v, according to its type              [[{data_structure}]]

* make(t Type, size ...IntegerType) Type :
  * allocate+initialize object of type slice|map|chan
      Like "new", 1st argument is a type, not a value.
    Unlike "new", return type is same as argument-type (vs pointer )

* new(Type) *Type : allocates memory and return pointer to newly
                    allocated type's "zero-value"

* panic(v interface{}) :
  · stop normal execution of current-goroutine
  · termination sequence can be controlled by the built-in func. recover() .

* recover() interface{} :
  * allows program to manage behavior for panicking goroutine.
    Executing a call to recover inside a deferred function                    [[{PM.TODO}]]
    (but not any function called by it) stops the panic sequence
    by restoring normal execution and retrieves the error
    value passed to the call of panic.
  * If recover called outside deferred-function it will not stop panic sequence.
    ...
[[}]]

## Error Management [[{qa.error_control.101]]

## contemplated errors [[{]]

* REF: <https://golang.org/ref/spec#Errors>
* predeclared error is defined as:
  ```
  | type error interface {  ← interface adopted by convention to
  |     Error() string        represent contemplated error condition
  | }                         (nil value representing no error).
  |
  | n, err := os.Read(f,...)
  | if err != nil {             ← Check for errors.
  |    // Fix contemplated error
  |    // (otherwise panic...)
  | }
  ```
* THE CONVENTION IN THE GO LIBRARIES IS THAT EVEN WHEN A PACKAGE
  USES PANIC INTERNALLY, ITS EXTERNAL API STILL PRESENTS EXPLICIT ERROR
  RETURN VALUES.
[[}]]

## error wrapping [[{qa.error_control.101,qa.101]]

* <httpr://pkg.go.dev/errors>
* package implementing functions to manipulate errors.
  * `func New   (text string)           error`
  * `func Join  (errs ...error)         error`
    returns new error wrapping errs (ignore nils) or nil if errs are all nil.
    text or error = newline-concatenated text by calling .Error on each element of errs
  * `func Unwrap(err error)             error`
    * If e.Unwrap() returns non-nil error w or a slice containing w,
      then we say that e wraps w, otherwise we say that e does NOT
      wrap any error.
    * Successive unwrapping of an error creates a tree.
  * `func Is    (err, target error)     bool`
    * returns true if `target` match  some element in err-tree.
    * `Is` It should be used for simple equality checks: [[{qa.best_patterns]]
      ```
      | if errors.Is(err, fs.ErrExist) // wright
      | if err == fs.ErrExist          // wrong                    [[qa.best_patterns}]]
      | (former will succeed if err wraps fs.ErrExist)
      ```
    * `Is` should ONLY shallowly compare err and target
      (vs calling Unwrap on either).
  * `func As    (err error, targetPtr any) bool` (v1.13+)
    run over err-tree searching for an error that can
    be assigned to targetPtr. If found, it performs the
    assignment and returns true. false otherwise.

### fmt.Errorf: quick way to create wrapper errors  <!-- { --> 

  ```
  | wrapsErr := fmt.Errorf("... %w ...", ..., err, ...)
  |                             └┴─ == error argument
  | var perr *fs.PathError
  |
  | if errors.As(err, &perr) {                //< Alt 1: Right
  | 	fmt.Println(perr.Path)
  | }
  |
  | if perr, ok := err.(*fs.PathError); ok {  //< Alt 2: Wrong
  | 	fmt.Println(perr.Path)
  | }
  | Alt 2 will succeed if err wraps an *fs.PathError
  ```
<!-- } -->

NOTE: `As`/`Is` can also be used by an error type to allow being treated a
   different/equivalent error type.
   Ex:
   func (m MyError) Is(target error) bool {
     return target == fs.ErrExist
   }
   Is(MyError{}, fs.ErrExist) // == true.
[[qa.error_control.101}]]

### defer/panic/recover (abort) on error [[{]]
* <https://blog.golang.org/defer-panic-and-recover>
* panic  : (java throw  )
* defer  : (java finally) cleanup after function exit
           to return to stable state.
* recover: (java catch  ) (only useful inside deferred functions)

  ```
  | $ cat errorhandling.go 
  | package main                                  
  |                                               
  | import (                                      
  |   "fmt"                                       
  | )                                             
  |                                               
  | type MyCustomError struct {                   
  |      data1, data2 string                      
  |      data3        int                         
  | }                                             
  |                                               
  | func (e MyCustomError) Error() string {       
  |      return fmt.Sprintf("%s %s %d:" ,         
  |              e.data1, e.data2, e.data3)       
  | }                                             
  |                                               
  | func returnMyCustomError() (int, error) {     
  |    return -1, MyCustomError{ "data1", "data2", 3 }
  | }                                             
  |                                               
  | func throwPanic() {                           
  |    panic ("Let's panic now");                 
  | }                                             
  |                                               
  | func main() {                                 
  |    defer func() /* catch( */ {                
  |       if r := recover(); r!=nil {   // <·· recover: Capture panics
  |          fmt.Printf("recovered\n")            
  |       }                                       
  |    }()                                        
  |                                               
  |    defer func()/* finally */ {                
  |      fmt.Printf("cleaning all resources\n")   
  |    }()                                        
  |                                               
  |    _, err := returnMyCustomError()            
  |    if  err != nil {                           
  |       fmt.Printf("%s\n",err.Error())          
  |    }                                          
  |    throwPanic()                               
  | }                                             
  ```
[[}]]
[[qa.error_control.101}]]

## Context (Core lib 1.7+) [[{101,arch.distributed,async/reactive.101,qa.error_control]]
* <https://pkg.go.dev/context>
* <https://blog.golang.org/context>
- Moved to Core lib in 1.7 (from golang.org/x/net/context).
- It allows the use of contexts for cancelation, timeouts, and passing request-scoped
  data (AAA/JWT Tokens, ...) in other standard library packages, including net,
  net/http, and os/exec and across API boundaries.
- safe to use by simultaneous concurrent goroutines. [[{concurrency.101}]]

  ```
  | type Context interface {
  |     Done() <- chan struct{}  // returns channel that is closed when 
  |                              // this Context is canceled/times out.
  |     Err() error              // indicates why context was canceled, 
  |                              // after Done channel is closed.
  |     Deadline() (deadline time.Time, ok bool) //
  |
  |     Value(key interface{}) interface{} // returns value or nil
  | }
  ```

* Example ussage: <https://github.com/go-chi/chi><br/>          [[{IO.http]]
  lightweight, composable router for building Go HTTP services.
  built on the new context package introduced in Go 1.7 to handle signaling,
  cancelation and request-scoped values across a handler chain. [[IO.http}]]
[[}]]

## Time Management [[{101.date_time]]
* <https://golang.org/pkg/time/>
  ```
  | start   := time.Now()
  | elapsed := time.Now().Sub (start) // time diff

  | func After(d Duration) <-chan Time
  | func Sleep(d Duration)
  | func Tick (d Duration)  <-chan Time

  | • type Duration:
  |   func ParseDuration(s string) (Duration, error)
  |   func Since(t Time) Duration
  |   func Until(t Time) Duration
  |   func (d Duration) Hours      () float64
  |   func (d Duration) Minutes    () float64
  |   func (d Duration) Nanoseconds() int64
  |   func (d Duration) Round(m Duration) Duration
  |   func (d Duration) Seconds() float64
  |   func (d Duration) String() string
  |   func (d Duration) Truncate(m Duration) Duration

  | • type Location:
  |   func FixedZone(name string, offset int) *Location
  |   func LoadLocation(name string) (*Location, error)
  |   func LoadLocationFromTZData(name string, data []byte) (*Location, error)
  |   func (l *Location) String() string
  | • type Month
  |   func (m Month) String() string
  | • type ParseError
  |   func (e *ParseError) Error() string
  | • type Ticker
  |   func NewTicker(d Duration) *Ticker
  |   func (t *Ticker) Stop()
  | • type type Time
  |   func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
  |   func Now() Time
  |   func Parse(layout, value string) (Time, error)
  |   func ParseInLocation(layout, value string, loc *Location) (Time, error)
  |   func Unix(sec int64, nsec int64) Time
  |   func (t Time) Add(d Duration) Time
  |   func (t Time) AddDate(years int, months int, days int) Time
  |   func (t Time) After(u Time) bool
  |   func (t Time) AppendFormat(b []byte, layout string) []byte
  |   func (t Time) Before(u Time) bool
  |   func (t Time) Clock() (hour, min, sec int)
  |   func (t Time) Date() (year int, month Month, day int)
  |   func (t Time) Day() int
  |   func (t Time) Equal(u Time) bool
  |   func (t Time) Format(layout string) string
  |   func (t *Time) GobDecode(data []byte) error
  |   func (t Time) GobEncode() ([]byte, error)
  |   func (t Time) Hour() int
  |   func (t Time) ISOWeek() (year, week int)
  |   func (t Time) In(loc *Location) Time
  |   func (t Time) IsZero() bool
  |   func (t Time) Local() Time
  |   func (t Time) Location() *Location
  |   func (t Time) MarshalBinary() ([]byte, error)
  |   func (t Time) MarshalJSON() ([]byte, error)
  |   func (t Time) MarshalText() ([]byte, error)
  |   func (t Time) Minute() int
  |   func (t Time) Month() Month
  |   func (t Time) Nanosecond() int
  |   func (t Time) Round(d Duration) Time
  |   func (t Time) Second() int
  |   func (t Time) String() string
  |   func (t Time) Sub(u Time) Duration
  |   func (t Time) Truncate(d Duration) Time
  |   func (t Time) UTC() Time
  |   func (t Time) Unix() int64
  |   func (t Time) UnixNano() int64
  |   func (t *Time) UnmarshalBinary(data []byte) error
  |   func (t *Time) UnmarshalJSON(data []byte) error
  |   func (t *Time) UnmarshalText(data []byte) error
  |   func (t Time) Weekday() Weekday
  |   func (t Time) Year() int
  |   func (t Time) YearDay() int
  |   func (t Time) Zone() (name string, offset int)
  |   type Timer
  |   func AfterFunc(d Duration, f func()) *Timer
  |   func NewTimer(d Duration) *Timer
  |   func (t *Timer) Reset(d Duration) bool
  |   func (t *Timer) Stop() bool
  |   type Weekday
  |   func (d Weekday) String() string
  ```
[[}]]

## Go Text Templates [[{strings.templates,devops,]]
* <https://pkg.go.dev/text/template?utm_source=oficina24x7.com>
- Used, among others, by helm charts.
- Example:
  ```
  | type Inventory struct {
  |     Material string
  |     Count    uint
  | }

  | tmpl, err := template.New("test")                   // ← Each template must be named
  |       .Parse(                                       // ← parse("compile") template
  |       "{{.Count}} items are made of {{.Material}}"  // ← UTF-8 Template
  | )
  | // A tpl s associated with 0+ tpls by using a tpl invocation to instantiate them
  | if err != nil { panic(err) }
  | err = tmpl.Execute(                                 // ← Execute template
  |        os.Stdout,
  |        Inventory{"wool", 17}                        // ←
  | )
  | if err != nil { panic(err) }

  | - TIPs:
  | {{- ...  : ← trim trailing white spaces.
  | ... -}}  : ← trim leading white-spaced.

  | Note: "{{- 3 }}"             → trim white spaces
  |       "{{-3  }}"             → -3 number
  |       "{{23 -}} < {{- 45}}"  → "23<45"
  | {{`"output"`}} ← raw string constant


  | Actions :
  | {{/* a comment */}}
  | {{- /* a comment with white space trimmed from preceding and following text */ -}}
  | - Comments:
  |   - dropped from output.
  |   - May contain newlines,
  |   - do not nest, must start and end at the delimiters.

  | {{if pipeline}} T1 {{end}}
  |   If pipeline value is empty, no output is generated; otherwise, T1 executed.
  | {{if pipeline}} T1 {{else}} T0 {{end}}
  |   If pipeline value is empty, T0 executed, otherwise, T1 executed.
  | {{if pipeline}} T1 {{else if pipeline}} T0 {{end}}

  | {{range pipeline}} T1 {{end}}
  |         ^
  |         array/slice/map/channel.
  |         cursor in T1 ("." dot) set to the successive elements
  | {{range pipeline}} T1 {{else}} T0 {{end}}

  | {{template "name"}}  (sort of "include")
  | template "name" executed with nil data.
  | {{template "name" pipeline}}
  | template "name" executed with dot set to the value of the pipeline.

  | {{block "name" pipeline}} T1 {{end}}
  | shorthand for defining and executing a template in place

  | {{with pipeline}} T1 {{end}}
  | If pipeline empty, no output , otherwisedot set to the value and T1 executed.
  | {{with pipeline}} T1 {{else}} T0 {{end}}

  | Arguments
  | (See official doc for other args)
  | - $piOver2 → expands to value of variable.
  |   $        → expands to data passed as argument to execute (start value of ".")
  | - .Field   → expands to value of (struct) field.
  | - $x.Field1→ expands to value of (struct) field of variable.
  | - .Key     → expands to value of (map   ) field of variable.
  | - $x.Field1.Key1.Field2.Key2
  | - .Method  → expands to (one/two) return value/s (with cursor as receiver)
  |     (If optional second args is non-nil, execution terminates
  |      and error returned to caller as value)
  | - function  → same as .Method but for functions (vs methods).
  |   The name of a niladic function, such as
  | - parenthesized instance of one the above, for grouping.
  |   - result may be accessed by a field or map key. Ex:
  |     - print (.F1 arg1) (.F2 arg2)
  |     - (.StructValuedMethod "arg").Field

  | Pipelines
  | A pipeline may be "chained" with '|'.

  | Variables
  | $variable := pipeline  ← Captures pipeline output for later reuse.

  | range $index, $element := pipeline  ← when pipeline output is an array/slice index
  |                                       or map key/value

  | Variable's scope is that of frame control structure ("if"/"with"/"range")  or
  | from declaration to end-of-template otherwise.

  | {{printf "%q" "output"}}   ← fun call.
  | {{"output" | printf "%q"}} ← fun call whose final arg comes from previous command.
  | {{printf "%q" (print "out" "put")}} ← A parenthesized argument.
  | {{"put" | printf "%s%s" "out" | printf "%q"}}
  | {{"output" | printf "%s" | printf "%q"}}
  | {{with "output"}}{{printf "%q" .}}{{end}}
  | {{with $x := "output" | printf "%q"}}{{$x}}{{end}}

  | {{with $x := "output"}}{{printf "%q" $x}}{{end}}    ← alt 1
  | {{with $x := "output"}}{{$x | printf "%q"}}{{end}}  ← alt 2 (pipelined)


  | Predefined global functions
  | - and x y : Returns boolean AND of its arguments
  | - call funA x y ..: return result of funA(x, y , ...)
  | - html            : Returns escaped HTML
  | - index x 1 2 3   : x[1][2][3], x is a map/slice/array.
  | - slice x 1 2     : is, in Go syntax, x[1:2],
  | - js              : Returns escaped JavaScript
  | - len x           : integer length of x
  | - not
  | - or
  | - print/f/ln      : alias for fmt.Sprint/f/ln
  | - urlquery x      : Returns escaped value of x
  | - comparision ops:
  |   - eq|ne|lt|le|gt|ge arg1 arg2

  | ------ Nested template definitions ------
  | {{define "T1"}}ONE{{end}}   ← Template definitions must appear at the top of tpl
  | {{define "T2"}}TWO{{end}}
  | {{define "T3"}}
  |    {{template "T1"}}        ← Using template, Output: ONE
  |    {{template "T2"}}                                  TWO
  | {{end}}
  | {{template "T3"}}`
  ```

## Sprig: Utility lib for Go templates [[{string.templates.sprig]]

* <https://masterminds.github.io/sprig/>

```
  - String : trim, wrap, randAlpha, plural, etc.
  - String List : splitList, sortAlpha, etc.
  - Integer Math : add, max, mul, etc.
  - Integer Slice : until, untilStep
  - Float Math : addf, maxf, mulf, etc.
  - Date : now, date, etc.
  - Defaults : default, empty, coalesce, fromJson, toJson,
    toPrettyJson, toRawJson, ternary
  - Encoding : b64enc, b64dec, etc.
  - Lists and List : list, first, uniq, etc.
  - Dictionaries and Dict : get, set, dict, hasKey, pluck,
    dig, deepCopy, etc.
  - Type Conversion : atoi, int64, toString, etc.
  - Path and Filepath : base, dir, ext, clean, isAbs,
    osBase, osDir, osExt, osClean, osIsAbs
  - Flow Control : fail
  - Advanced
    - UUID: uuidv4
    - OS : env, expandenv
    - Version Comparison : semver, semverCompare
    - Reflection: typeOf, kindIs, typeIsLike, etc.
    - Cryptographic and Security: derivePassword, sha256sum,
      genPrivateKey, etc. [[[{security.cryptography}]]
    - Network: getHostByName
```
[[string.templates.sprig}]]

[[strings.templates}]]


## Flesh [[{IO.http.server,qa.UX.flesh]]

* <https://github.com/gravityblast/fresh>
  Fresh is a command line tool that builds and (re)starts your web
  application everytime you save a Go or template file.
   If the web framework you are using supports the Fresh runner,
  it will show build errors on your browser.
   It currently works with Traffic, Martini and gocraft/web.
  ```
  | $ go get github.com/pilu/fresh # Installation
  | $ cd /path/to/myapp            # Ussage
  | $ Start fresh
  ```

     It will watch for file events, and every time you
  create/modify/delete a file it will build and restart the
  application. If go build returns an error, it will log it in the tmp
  folder.                                         [[01_PM.UX.flesh}]]


# DATA STRUCTURES [[{101.data_structure]]

## Structs
  ```
  | type Circle struct {
  |   x, y, r float64
  |   color   string
  | }
  | circle1 := Circle{0,0,4,"blue"}
  |
  | func (c Circle) area() float64 {      <- friend-function for struct
  |   return math.Pi * c * c * r             See also related <#golang_interfaces>
  | }
  | circle1.area()                        <- Invoking friend function
  |
  | type Wheel struct {
  |    Circle                             <- embedded (composed) type
  |    material string
  | }
  | wheel1 := Wheel1{circle1, "iron"}
  | wheel1.area                           <- calls wheel1.circle1.area
  ```

## Arrays

  ```
  | var x [5]int        ← 0-initialized   <- ARRAY DEFINITION.             [[{qa.inmu_code}]]
  |     x[4] = 100      ← [ 0 0 0 0 100]     FIXED LENGTH AT COMPILE TIME.
  |     len(x)
  | var y := [3]float64 { 1.0, 2.0, 3.0}  <- value-initialized
  |
  | y_copy := y                           <- VALUE SEMANTIC, y_copy is a COPY-OF-ARRAY
  | y_cpy[0] = 25                            <- y[0] not modified.
  | byteArrayFromStr := []byte("a slice")
  |
  | array01 := []struct {                 <- array of anonymous struct type
  |   field1 string,                         used just in scope 'array01'
  |   field2 string
  | } {
  |   {"value_1_1", "value_1_2"},
  |   {"value_2_1", "value_2_2"},
  |   ...
  | }
  | cases_l[0].field1
  | cases_l[0].field2
  |
  | for idx, element :=  range array1 {  <- WALKING OVER ARRAYS
  |   // do something                       ===================
  | }
  ```

## Slices (array segments, Dyn.Size)

- Internally, slice they look to be a link of arrays.
- More widely used in code than arrays.

  ```
  slice1 :=  make ([]float64 /*type*/, // <·· zero-initialized
                           5 /*len*/   ,
                          10 /*capacity*/)
  array1 := []int{1,2,3,4,5}
  slice2 := array1[0:5]                <- Create slice from array
  slice2 :=append(slice2,4,5,[]int{6}) <- Slice grows on-demand.
  s3_copy := slice3                    <- reference semantics (both slices modify same values)
  s3_copy[0] = 1                       <- slice3[0] will change too.
  copy(slice3,slice2)                  <- copy of slice2 up to len [[{01_PM.TODO}]]
  ```

## Maps (Dyn.size) [[{]]

* https://golang.org/ref/spec#Map_types]
  (Dictiona./Associat.arrays/hashtables)

  ```
  map1 :=  make (  map [string]int) // <···Alt 1:Declare map
  map1["key"] = 10                  //       <·· Init keys
  map2 := map[string]int            // <·· Alt 2:Declare with initial key/values
             {"three": 3,...}
  delete(map1, "key")               // <·· Delete by key.
  map1["no_key"]                    // <·· WARN: "ZERO TYPE VALUE" returned (no throw, no nil)
  if value1, ok := map1["key1"]; ok {// <·· one line key-exists check
     ...
  } else { ... }
  map2 := map[string]map[string]string{
    "H": map[string]string{
      "name":"Hydrogen",
      "state":"gas",
    },
    ...
  }

  for key, value :=   range  map1 {      ● WALK OVER MAPS
    fmt.Println(                           Alt: for _, value := .. if key is not needed
      "Key:", key, "Value:", value)
  }
  ```
[[}]]

## Lists [[{data_structure.list]]

  ```
  import ("container/list")
  var x list.List
  x.PushBack(1)
  x.PushBack(2)
  ...

  import ("sort")                       ● LIST SORTING
  type ByOrder1 []MyType
  func (this ByOrder1) Len() int {
    return   len (this)
  }
  func (this ByOrder1)
    Less(i, j int) bool {
    return this[i].Name < this[j].Name
  }
  func (this ByOrder1) Swap(i, j int) {
    this[i], this[j] = this[j], this[i]
  }
  ...
  sort .Sort (ByOrder1(kids))  // <······ Execute sort

  for e := l.Front();  <············┐  ● WALK OVER LISTS
       e != nil; e = e.Next() {     └···· NOTE: l is a *List
      // do something with e.Value
  }
  ```

[[}]]
[[101.data_structure}]]
[[101}]]
